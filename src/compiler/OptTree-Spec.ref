$INCLUDE "LibraryEx";

*$FROM TreeUtils
$EXTERN ExtractVariables, ExtractVariables-Expr, NewVarName, AddSuffix;

*$FROM GenericMatch
$EXTERN GenericMatch, Solve-Spec;

*$FROM Log
$EXTERN Log-PutLine, Log-InlineExpr;

*$FROM DisplayName
$EXTERN DisplayName;

*$FROM GlobalGen
$EXTERN GlobalGen;

*$FROM OptTree-StopRelation
$EXTERN OptTree-CanonizeTuple, OptTree-CanonizeExpr;
$EXTERN OptTree-CheckTupleStopRelation, OptTree-CheckExprStopRelation;

/**
  <OptTree-Spec-Prepare s.OptSpec e.AST> == e.AST^

  s.OptSpec ::= OptSpec | NoOpt

  В дерево добавляется узел (SpecInfo e.SpecInfo).

  e.SpecInfo ::= (e.SpecFuncNames) e.SpecInfo-Specific
  e.SpecFuncNames ::= (e.FuncName)*
  e.SpecInfo-Specific ::= t.FunctionInfo* (e.Histories)
  t.FunctionInfo ::= ((e.Name) (e.Pattern) (e.Body) s.NextCounter t.Signature*)
  t.Signature ::= ((e.InstanceName) e.Expression)
  e.InstanceName ::= e.Name
  e.Histories ::= ((e.InstanceName) e.History)*
  e.History ::= ((e.FuncName) e.Expression)*
*/
$ENTRY OptTree-Spec-Prepare {
  NoOpt e.AST = e.AST;

  OptSpec e.AST-B (SpecInfo e.SpecInfo) e.AST-E
    = <Prepare-Aux (e.SpecInfo) e.AST-B e.AST-E>;

  OptSpec e.AST
    = (/* no names */) /* no info */ (/* no histories */)
    : e.EmptyInfo
    = <Prepare-Aux (e.EmptyInfo) e.AST>;
}

Prepare-Aux {
  ((e.KnownNames) e.KnownInfo (e.KnownHistories)) e.AST
    = <Fetch
        ((/* no names */) /* no info */ (/* no histories */)) e.AST
        <Pipe
          (&MapAccum
            {
              /* Игнорируем новые $SPEC’и для известных функций */
              ((e.Names) e.Info (e.Histories)) (Spec t.Name e.Pattern)
                , e.KnownNames : e._B t.Name e._E
                = ((e.Names) e.Info (e.Histories)) /* пропускаем */;

              ((e.Names) e.Info (e.Histories)) (Spec t.Name e.Pattern)
                = t.Name : (e.Name)
                = (
                    (e.Names t.Name)
                    e.Info (t.Name (e.Pattern))
                    (e.Histories <TrivialHistory e.Name (e.Pattern)>)
                  )
                  <Log-PutLine
                    'New $SPEC function: ' <DisplayName e.Name> ' '
                    <Log-InlineExpr e.Pattern>
                  >;

              ((e.Names) e.Info (e.Histories)) t.Other
                = ((e.Names) e.Info (e.Histories)) t.Other;
            }
          )
          (&MapAccum
            {
              ((e.Names) e.Info-B (t.Name (e.Pattern)) e.Info-E (e.Histories))
              (Function s.ScopeClass t.Name Sentences e.Body)
                = (
                    (e.Names)
                    e.Info-B (t.Name (e.Pattern) (e.Body) 1) e.Info-E
                    (e.Histories)
                  )
                  (Function s.ScopeClass t.Name Sentences e.Body);

               ((e.Names) e.Info) t.Other = ((e.Names) e.Info) t.Other;
            }
          )
        >
      >
    : ((e.NewNames) e.NewInfo (e.NewHistories)) e.AST^

    = <AddGuardSentences e.NewInfo> : e.NewInfo^
    = <AddGuardEnums e.AST> : e.AST^

    = <CreateRemainderFunctions e.NewInfo> : e.NewInfo^

    = (SpecInfo
        (e.KnownNames e.NewNames)
        e.KnownInfo e.NewInfo
        (e.KnownHistories e.NewHistories)
      )
      e.AST
}

*TrivialHistory {
*  e.Name (e.Pattern)
*    = (<AddSuffix e.Name ('@' 0)>)
*      <Map
*        {
*          (s.Mode e.Index)
*            , <IsSpecStaticVar (s.Mode e.Index)> : True
*            = ((Var s.Mode e.Index));
*
*          (s.Mode e.Index) = /* пропускаем */;
*        }
*        <ExtractVariables-Expr e.Pattern>
*      >
*    : e.HistoryRecord
*    = ((e.Name) (e.HistoryRecord));
*}

TrivialHistory {
  e.Name (e.Pattern)
    = (<AddSuffix e.Name ('@' 0)>)
      e.Pattern
    : e.HistoryRecord
    = ((e.Name) (e.HistoryRecord));
}

* Добавляет вызов аварийной функции Func@0 в конец каждой специализируемой
* функции.Этот вызов облегчает отладку при аварийном завершении программы
* в специализированной функции.
AddGuardSentences {
  e.Info
    = <Map
        {
          ((e.Name) (e.SpecPattern) (e.Sentences) e.Signatures)
            = <AddSuffix e.Name ('@' 0)> : e.GuardName
            = (e.SpecPattern)
              ((CallBrackets (Symbol Name e.GuardName) e.SpecPattern))
            : e.GuardSentence
            = (
                (e.Name)
                (e.SpecPattern)
                (e.Sentences (e.GuardSentence))
                e.Signatures
              )
        }
        e.Info
      >
}

AddGuardEnums {
  e.AST
    = <Map
        {
          (Function s.ScopeClass (e.Name) e.Body)
            = (Function s.ScopeClass (e.Name) e.Body) <MakeGuardEnum e.Name>;

          (Declaration s.ScopeClass e.Name)
            = (Declaration s.ScopeClass e.Name) <MakeGuardEnum e.Name>;

          t.OtherItem = t.OtherItem;
        }
        e.AST
      >
}

GuardEnumName {
  e.Name = <AddSuffix e.Name ('@' 0)>
}

MakeGuardEnum {
  e.Name = (Function GN-Local (<GuardEnumName e.Name>) Sentences /* пусто */)
}

* Обеспечивает специализацию функций Func*n. Такие функции могут получаться
* при частичной прогонке функций, помеченных как прогоняемые
* и специализированные одновременно. Этот остаток тоже имеет смысл
* специализировать.
CreateRemainderFunctions {
  e.Info = <Map (&CreateRemainderFunctions-OneFunction 0) e.Info>
}

CreateRemainderFunctions-OneFunction {
  s.Count ((e.Name) (e.SpecPattern) ((e.GuardSentence)) 1 /* нет сигнатур */)
    = /* пусто */;

  s.Count ((e.Name) (e.SpecPattern) (e.Sentences) 1 /* нет сигнатур */)
    = s.Count
    : {
        0 = e.Name;
        s._ = <AddSuffix e.Name ('*' s.Count)>;
      }
    : e.RemainderName
    = ((e.RemainderName) (e.SpecPattern) (e.Sentences) 1 /* нет сигнатур */)
      <CreateRemainderFunctions-OneFunction
        <Inc s.Count>
        ((e.Name) (e.SpecPattern) (<Drop e.Sentences>) 1 /* нет сигнатур */)
      >;
}

Drop {
  t.First e.Rest = e.Rest
}

/**
  <OptTree-Spec s.OptSpec e.AST> == e.AST^

  s.OptSpec ::= OptSpec | NoOpt
*/
$ENTRY OptTree-Spec {
  NoOpt e.AST = <ColdAll e.AST>;

  OptSpec e.AST-B (SpecInfo (e.Names) e.SpecInfo (e.Histories)) e.AST-E
    = <PrintHistories e.Histories>
      <MapAccum
        &SpecUnit
        (e.SpecInfo (e.Histories) (/* new functions */))
        e.AST-B e.AST-E
      >
    : (e.SpecInfo^ (e.Histories^) (e.NewFunctions)) e.AST
    = (SpecInfo (e.Names) e.SpecInfo (e.Histories)) e.AST e.NewFunctions;
}

ColdAll {
  e.AST
    = <Map
        {
          (Function s.ScopeClass (e.Name) e.Body)
            = (ColdFunction SPEC s.ScopeClass (e.Name) e.Body);

          t.OtherItem = t.OtherItem;
        }
        e.AST
      >;
}

PrintHistories {
  e.Histories = <Map &PrintHistory e.Histories>;
}

PrintHistory {
  ((e.Function) e.History)
    = <Log-PutLine
        'History of ' <DisplayName e.Function> '\n'
        <Map
          {
            ((e.FuncName) e.StaticVarsVals)
              = '    ' <DisplayName e.FuncName> ':'
                ' [' <PrintSignature e.StaticVarsVals> ']\n';
          }
          e.History
        >
      >
}

PrintSignature {
  /* пусто */ = /* пусто */;
  t.First e.Last
    = <PrintSignatureItem t.First>
      <Map { t.Item = ', ' <PrintSignature t.Item> } e.Last>
}

PrintSignatureItem {
  (e.Expr) = <Log-InlineExpr e.Expr>;
}

SpecUnit {
  (e.SpecInfo
    (e.Histories-B (t.Name e.History) e.Histories-E) (e.NewFunctions)
  )
  (Function s.ScopeClass t.Name Sentences e.Sentences)
    = <MapAccum
        &SpecSentence
        (
          e.SpecInfo (e.Histories-B (t.Name e.History) e.Histories-E)
          (e.History) (e.NewFunctions)
        )
        e.Sentences
      >
    : (e.SpecInfo^ (e.Histories) (e.History^) (e.NewFunctions^)) e.Sentences^
    = (e.SpecInfo (e.Histories) (e.NewFunctions))
      (ColdFunction SPEC s.ScopeClass t.Name Sentences e.Sentences);

  (e.SpecInfo (e.Histories) (e.NewFunctions))
  (Function s.ScopeClass t.Name Sentences e.Sentences)
    = <MapAccum
        &SpecSentence
        (e.SpecInfo (e.Histories) (/* empty history */) (e.NewFunctions))
        e.Sentences
      >
    : (e.SpecInfo^ (e.Histories^) (e.History) (e.NewFunctions^))
      e.Sentences^
    = (e.SpecInfo (e.Histories) (e.NewFunctions))
      (ColdFunction SPEC s.ScopeClass t.Name Sentences e.Sentences);

  (e.SpecInfo (e.Histories) (e.NewFunctions)) t.Other
    = (e.SpecInfo (e.Histories) (e.NewFunctions)) t.Other;
}

/**
  <SpecSentence
    (e.SpecInfo (e.Histories) (e.History) (e.NewFunctions))
    t.Sentence
  >
    == (e.SpecInfo^ (e.Histories^) (e.History^) (e.NewFunctions^) t.Sentence^

  t.Sentence ::= ((e.Pattern) e.Conditions (e.Result))

  Функция ищет в правой части предложения вызовы специализируемых функций
  и пытается выполнить специализацию для него
*/
SpecSentence {
  (e.SpecInfo (e.Histories) (e.History) (e.NewFunctions))
  ((e.Pattern) e.Conditions (e.Result))
    = <MapAccum
        {
          (e.SpecInfo^ (e.Histories^) (e.History^) (e.NewFunctions^))
          (Condition (e.Name) (e.ConditionResult) (e.ConditionPattern))
            = <SpecResult
                (e.SpecInfo (e.Histories) (e.History) (e.NewFunctions))
                e.ConditionResult
              >
            : (e.SpecInfo^ (e.Histories^) (e.History^) (e.NewFunctions^))
              e.ConditionResult^
            = (e.SpecInfo (e.Histories) (e.History)  (e.NewFunctions))
              (Condition (e.Name) (e.ConditionResult) (e.ConditionPattern));
        }
        (e.SpecInfo (e.Histories) (e.History) (e.NewFunctions))
        e.Conditions
      >
    : (e.SpecInfo^ (e.Histories^) (e.History^) (e.NewFunctions^)) e.Conditions^
    = <SpecResult
        (e.SpecInfo (e.Histories) (e.History) (e.NewFunctions))
        e.Result
      >
    : (e.SpecInfo^ (e.Histories^) (e.History^) (e.NewFunctions^)) e.Result^
    = (e.SpecInfo (e.Histories) (e.History) (e.NewFunctions))
      ((e.Pattern) e.Conditions (e.Result));
}


/**
  <SpecResult
    (e.SpecInfo (e.Histories) (e.History) (e.NewFunctions))
    e.Results
  >
    == (e.SpecInfo^ (e.Histories^) (e.History^) (e.NewFunctions^)) e.Result^

  Функция разбирает результирующее выражение, ищет в нем вызовы специализируемых
  функций и замыканий и пытается выполнить специализацию для них
*/
SpecResult {
  (e.SpecInfo (e.Histories) (e.History) (e.NewFunctions)) e.Result
    = <SpecResult-Pass
        Functions (e.SpecInfo (e.Histories) (e.History) (e.NewFunctions))
        e.Result
      >
    : (e.SpecInfo^ (e.Histories^) (e.History^) (e.NewFunctions^)) e.Result^
    = <SpecResult-Pass
        Closures (e.SpecInfo (e.Histories) (e.History) (e.NewFunctions))
        e.Result
      >;
}

SpecResult-Pass {
  s.Pass (e.SpecInfo (e.Histories) (e.History) (e.NewFunctions)) e.Result
    = <MapAccum
        {
          (e.Info (e.CurHistories) (e.CurHistory) (e.NewFuncs)) t.Result-T
            = <SpecTerm
                s.Pass (e.Info (e.CurHistories) (e.CurHistory) (e.NewFuncs))
                t.Result-T
              >;
        }
        (e.SpecInfo (e.Histories) (e.History) (e.NewFunctions))
        e.Result
      >;
}

/**
  <SpecTerm (e.SpecInfo (e.Histories) (e.History) (e.NewFunctions)) t.Term>
    == (e.SpecInfo^ (e.Histories^) (e.History^) (e.NewFunctions^)) t.Term^

  Функция ищет в терме вызовы специализируемых функций
  и пытается выполнить специализацию для него
*/
SpecTerm {
  s.Pass (e.SpecInfo (e.Histories) (e.History) (e.NewFunctions))
  (CallBrackets (Symbol Name e.Name) e.Expression)
    , e.Name : e._ '@' 0
    /*
      Аргументы вызовов аварийных функций специализатора специализировать
      нельзя, они должны оставаться неизменными.

      Вместо этого мы все ссылки на функции заменим ссылками на пустые функции —
      это необходимо, чтобы инструмент удаления неиспользуемых функций удалил
      те, по которым программа уже специализировалась.

      Например, для <Map {{ &F\1 … }} …> в аварийном предложении останется
      &F\1, которая сама может тянуть ненужные функции (и занимать собой
      сгенерированный код). Мы заменим её на пустую функцию.
    */
    = (e.SpecInfo (e.Histories) (e.History) (e.NewFunctions))
      (CallBrackets (Symbol Name e.Name) <ReplaceToGuards e.Expression>);

  s.Pass (e.SpecInfo (e.Histories) (e.History) (e.NewFunctions))
  (CallBrackets (Symbol Name e.Name) e.Expression)
    = <SpecResult-Pass
        s.Pass (e.SpecInfo (e.Histories) (e.History) (e.NewFunctions))
        e.Expression
      >
    : (e.SpecInfo^ (e.Histories^) (e.History^) (e.NewFunctions^)) e.Expression^

    = s.Pass
    : {
        Functions = &TrySpecCall;
        Closures = &SkipSpecCall;
      }
    : s.TrySpecCall

    = <s.TrySpecCall
        (e.SpecInfo (e.Histories) (e.History) (e.NewFunctions))
        (CallBrackets (Symbol Name e.Name) e.Expression)
      >;

  s.Pass (e.SpecInfo (e.Histories) (e.History) (e.NewFunctions))
  (CallBrackets e.Expression)
    = <SpecResult-Pass
        s.Pass (e.SpecInfo (e.Histories) (e.History) (e.NewFunctions))
        e.Expression
      >
    : (e.SpecInfo^ (e.Histories^) (e.History^) (e.NewFunctions^)) e.Expression^
    = (e.SpecInfo (e.Histories) (e.History) (e.NewFunctions))
      (CallBrackets e.Expression);

  s.Pass (e.SpecInfo (e.Histories) (e.History) (e.NewFunctions))
  (ClosureBrackets e.ClosureContent)
    = <SpecResult-Pass
        s.Pass (e.SpecInfo (e.Histories) (e.History) (e.NewFunctions))
        e.ClosureContent
      >
    : (e.SpecInfo^ (e.Histories^) (e.History^) (e.NewFunctions^))
      e.ClosureContent^

    = s.Pass
    : {
        Functions = &SkipSpecCall;
        Closures = &TrySpecCall;
      }
    : s.TrySpecCall

    = <s.TrySpecCall
        (e.SpecInfo (e.Histories) (e.History) (e.NewFunctions))
        (CallBrackets e.ClosureContent (Var 'e@'))
      >
    : (e.SpecInfo^ (e.Histories^) (e.History^) (e.NewFunctions^))
      (CallBrackets e.ClosureContent^ (Var 'e@'))

    = e.ClosureContent
    : {
        (Symbol Name e.OptName) /* пусто */
          = (e.SpecInfo (e.Histories) (e.History) (e.NewFunctions))
            (Symbol Name e.OptName);

        e.ClosureContent^
          = (e.SpecInfo (e.Histories) (e.History) (e.NewFunctions))
            (ClosureBrackets e.ClosureContent);
      };


  s.Pass (e.SpecInfo (e.Histories) (e.History) (e.NewFunctions))
    (Brackets e.Expression)
    = <SpecResult-Pass
        s.Pass (e.SpecInfo (e.Histories) (e.History) (e.NewFunctions))
        e.Expression
      >
    : (e.SpecInfo^ (e.Histories^) (e.History^) (e.NewFunctions^)) e.Expression^
    = (e.SpecInfo (e.Histories) (e.History) (e.NewFunctions))
      (Brackets e.Expression);

  s.Pass (e.SpecInfo (e.Histories) (e.History) (e.NewFunctions))
    (ADT-Brackets (e.Name) e.Expression)
    = <SpecResult-Pass
        s.Pass (e.SpecInfo (e.Histories) (e.History) (e.NewFunctions))
        e.Expression
      >
    : (e.SpecInfo^ (e.Histories^) (e.History^) (e.NewFunctions^)) e.Expression^
    = (e.SpecInfo (e.Histories) (e.History) (e.NewFunctions))
      (ADT-Brackets (e.Name) e.Expression);

  s.Pass (e.SpecInfo (e.Histories) (e.History) (e.NewFunctions)) t.Other
   = (e.SpecInfo (e.Histories) (e.History) (e.NewFunctions)) t.Other;
}

ReplaceToGuards {
  e.Expression
    = <Map
        {
          (s.Brackets e.Nested)
            , Brackets CallBrackets ClosureBrackets : e._ s.Brackets e._
            = (s.Brackets <ReplaceToGuards e.Nested>);

          (ADT-Brackets (e.Name) e.Nested)
            = (ADT-Brackets (e.Name) <ReplaceToGuards e.Nested>);

          /* Уже пустая функция, ничего не делаем с ней */
          (Symbol Name e.Name '@' 0) = (Symbol Name e.Name '@' 0);

          (Symbol Name e.Name) = (Symbol Name <GuardEnumName e.Name>);

          t.Other = t.Other;
        }
        e.Expression
      >
}

TrySpecCall {
  (
    e.SpecInfo-B ((e.Name) e.Info) e.SpecInfo-E
    (e.Histories) (e.History) (e.NewFunctions)
  )
  (CallBrackets (Symbol Name e.Name) e.Expression)
    = <SpecCall (e.Name) e.Info (e.Expression) (e.History)>
    : (e.Info^) t.NewCall e.NewFunction (e.NewHistory)
    = (
        ((e.Name) e.Info) e.SpecInfo-B e.SpecInfo-E
        (e.Histories e.NewHistory)
        (e.History)
        (e.NewFunctions e.NewFunction)
      )
      t.NewCall;

  (e.SpecInfo (e.Histories) (e.History) (e.NewFunctions))
  (CallBrackets (Symbol Name e.Name) e.Expression)
    = (e.SpecInfo (e.Histories) (e.History) (e.NewFunctions))
      (CallBrackets (Symbol Name e.Name) e.Expression);
}

SkipSpecCall {
  (e.SpecInfo (e.Histories) (e.History) (e.NewFunctions)) t.CallTerm
    = (e.SpecInfo (e.Histories) (e.History) (e.NewFunctions)) t.CallTerm;
}

/**
  <SpecCall
    (e.Name) (e.SpecPattern) (e.Body)
    s.CurrentNumber e.Signatures (e.Argument) (e.History)
  >
    == ((e.SpecPattern) (e.Body) s.NextNumber e.Signatures t.NewSignature)
        t.NewCall t.NewFunction (e.NewHistory)

  Функция пытается выполнить специализацию для заданного вызова:
  # ищет среди сигнатур готовых специализированных функций похожую
    * если сигнатура найдена, заменяем исходный вызов на вызов найденной функции
    * если сигнатура не найдена выполняем специализацию для аргументов вызова
      # формируем новый вызов
      # формируем определение новой специализированной функции
  # возвращает e.Info с новой сигнатурой,
    новый вызов
    определение новой специализированной функции
*/
*SpecCall {
*  (e.Name) (e.SpecPattern) (e.Body) s.NextNumber e.Signatures
*  (e.Argument) (e.History)
*
*    , <GenericMatch-Wrapper (e.Argument) (e.SpecPattern)>
*    : Clear (e.StaticMatches) (e.DynamicMatches)
*
*    = True : s.NeedRelationCheck
*
*    = <SpecCall-Matches
*        (e.Name) (e.SpecPattern) (e.Body) s.NextNumber e.Signatures
*        (e.Argument) (e.StaticMatches) (e.DynamicMatches) (e.History)
*        s.NeedRelationCheck
*      >;
*
*  (e.Name) (e.SpecPattern) (e.Body) s.NextNumber e.Signatures
*  (e.Argument) (e.History)
*    = ((e.SpecPattern) (e.Body) s.NextNumber e.Signatures)
*      (CallBrackets (Symbol Name e.Name) e.Argument)
*      /* no new functions */
*      (/* no new history */);
*}

*SpecCall-Matches {
*  (e.Name) (e.SpecPattern) (e.Body) s.NextNumber e.Signatures
*  (e.Argument) (e.StaticMatches) (e.DynamicMatches) (e.History)
*  s.NeedRelationCheck
*
*    , <ExtractCalls e.StaticMatches> : (e.Calls) e.StaticMatches^
*
*    , <PrepareSignature e.StaticMatches (e.SpecPattern)> : e.Signature
*
*    , <IsTrivialSubstitutions e.StaticMatches> : False
*
*    = <SpecCall-Aux
*        (e.Name) (e.SpecPattern) (e.Body)
*        s.NextNumber e.Signatures (e.Argument)
*        (e.Signature) (e.StaticMatches) (e.DynamicMatches)
*        (e.Calls) (e.History) s.NeedRelationCheck
*      >;
*
*  (e.Name) (e.SpecPattern) (e.Body) s.NextNumber e.Signatures
*  (e.Argument) (e.StaticMatches) (e.DynamicMatches) (e.History)
*  s.NeedRelationCheck
*    = ((e.SpecPattern) (e.Body) s.NextNumber e.Signatures)
*      (CallBrackets (Symbol Name e.Name) e.Argument)
*      /* no new functions */
*      (/* no new history */);
*}

*SpecCall-Aux {
*  (e.Name) (e.SpecPattern) (e.Body) s.NextNumber e.Signatures (e.Argument)
*  (e.Signature) (e.StaticMatches) (e.DynamicMatches) (e.Calls) (e.History)
*  s.NeedRelationCheck
*
*    = <PrepareArgOrPattern (e.StaticMatches) (e.DynamicMatches) e.SpecPattern>
*    : e.SpecializedFuncArgument
*
*    = <ApplySubst-Expr (e.Calls) e.SpecializedFuncArgument>
*    : e.SpecializedFuncArgument^
*
*    = <Spec-FindInSignatures (e.Signature) e.Signatures>
*    : {
*        Found e.InstanceName (e.Signatures^)
*          = ((e.SpecPattern) (e.Body) s.NextNumber e.Signatures)
*            (CallBrackets
*              (Symbol Name e.InstanceName) e.SpecializedFuncArgument
*            )
*            /* no new functions */
*            (/* no new history */);
*
*        NotFound e.Signatures^
*
*          = s.NeedRelationCheck
*          : {
*              True
*                = <HasHigmanKruskalRelation
*                    (e.Name) (<OptTree-CanonizeTuple e.Signature>)
*                    e.History
*                  >;
*
*              False = False;
*            }
*          : e.RelationCheckResult
*
*          = e.RelationCheckResult
*          : {
*              True e.HistorySignature
*
*                = <MakeGeneralization
*                    (e.Signature) (e.HistorySignature) (e.Argument)
*                    (e.SpecPattern) (e.StaticMatches) (e.Name)
*                    (e.Body) s.NextNumber (e.Signatures) (e.DynamicMatches)
*                    (e.History) (e.Calls)
*                  >;
*
*              False
*                = <PrepareSpecializedFuncBody
*                    (e.SpecPattern) (e.StaticMatches) e.Body
*                  >
*                : e.SpecializedFuncBody
*
*                , <IsSoundBody e.SpecializedFuncBody>
*                : {
*                    True
*                      = <AddSuffix e.Name ('@' s.NextNumber)> : e.InstanceName
*                      = (
*                          (e.SpecPattern) (e.Body) <Inc s.NextNumber>
*                          e.Signatures ((e.InstanceName) e.Signature)
*                        )
*                        (CallBrackets
*                          (Symbol Name e.InstanceName)
*                          e.SpecializedFuncArgument
*                        )
*                        (Function
*                          GN-Local (e.InstanceName)
*                          Sentences e.SpecializedFuncBody
*                        )
*                        (
*                          (
*                            (e.InstanceName) e.History
*                            ((e.InstanceName) e.Signature)
*                          )
*                        );
*
*                    False
*                      = ((e.SpecPattern) (e.Body) s.NextNumber e.Signatures)
*                        (CallBrackets (Symbol Name e.Name) e.Argument)
*                        /* no new functions */
*                        (/* no new history */);
*                  };
*
*              e.Other
*                = ((e.SpecPattern) (e.Body) s.NextNumber e.Signatures)
*                  (CallBrackets (Symbol Name e.Name) e.Argument)
*                  /* no new functions */
*                  (/* no new history */);
*            };
*      };
*}

*ExtractCalls {
*  e.StaticMatches
*
*    = <Map
*        {
*          (e.Expr ':' t.Var) = <ExtractVariables-Expr e.Expr>;
*        }
*        e.StaticMatches
*      >
*    : e.UsedVars
*
*    = <MapAccum
*        {
*          (e.Calls (e.UsedVars^)) (e.Expr ':' t.Var)
*            = <ExtractCalls-Expr (e.Calls (e.UsedVars)) e.Expr>
*            : (e.Calls^ (e.UsedVars^)) e.Expr^
*            = (e.Calls (e.UsedVars)) (e.Expr ':' t.Var);
*        }
*        (/* calls */ (e.UsedVars)) e.StaticMatches
*      >
*    : (e.Calls (e.UsedVars^)) e.StaticMatches^
*
*    = (e.Calls) e.StaticMatches
*}

ExtractCalls-Expr {
  (e.Calls (e.UsedVars)) e.Expr
    = <MapAccum &ExtractCalls-Term (e.Calls (e.UsedVars)) e.Expr>;
}

ExtractCalls-Term {
  (e.Calls (e.UsedVars)) (CallBrackets e.Expr)
    = <NewVarName (e.UsedVars) 'eCall'> : (e.UsedVars^) e.NewVar
    = (e.Calls ((CallBrackets e.Expr) ':' (e.NewVar)) (e.UsedVars))
      (Var e.NewVar);

  (e.Calls (e.UsedVars)) (Brackets e.Expr)
    = <ExtractCalls-Expr (e.Calls (e.UsedVars)) e.Expr>
    : (e.Calls^ (e.UsedVars^)) e.Expr^
    = (e.Calls (e.UsedVars)) (Brackets e.Expr);

  (e.Calls (e.UsedVars)) (ADT-Brackets (e.Name) e.Expr)
    = <ExtractCalls-Expr (e.Calls (e.UsedVars)) e.Expr>
    : (e.Calls^ (e.UsedVars^)) e.Expr^
    = (e.Calls (e.UsedVars)) (ADT-Brackets (e.Name) e.Expr);

  (e.Calls (e.UsedVars)) t.OtherTerm = (e.Calls (e.UsedVars)) t.OtherTerm;
}

*IsSoundBody {
*  e.Body
*    , <FindClosuresInPatterns-Body e.Body>
*    : {
*        /* пусто */ = True;
*        e.FoundClosures = False;
*      };
*}
*
*FindClosuresInPatterns-Body {
*  e.Body
*    = <Map
*        {
*          ((e.Pattern) e.Conditions (e.Result))
*            = <FindClosuresInPatterns-Pattern
*                e.Pattern
*                <Map
*                  {
*                    (Condition (e.Name) (e.CondResult) (e.CondPattern))
*                      = e.CondPattern;
*                  }
*                  e.Conditions
*                >
*              >;
*        }
*        e.Body
*      >;
*}
*
*FindClosuresInPatterns-Pattern {
*  e.Pattern = <Map &FindClosuresInPatterns-Term e.Pattern>;
*}
*
*FindClosuresInPatterns-Term {
*  (Symbol s.Type e.Info) = /* пусто */;
*  (Var s.Type e.Index) = /* пусто */;
*
*  (Brackets e.Pattern)
*    = <FindClosuresInPatterns-Pattern e.Pattern>;
*  (ADT-Brackets (e.Name) e.Pattern)
*    = <FindClosuresInPatterns-Pattern e.Pattern>;
*
*  (ClosureBrackets e.Context) = Found;
*}

*PrepareSignature {
*  e.StaticMatches (e.SpecPattern)
*    /* ExtractVariables-Expr сохраняет порядок переменных в выражении */
*    = <ExtractVariables-Expr e.SpecPattern> : e.SpecVars
*    = <PrepareSignature-SortVars e.StaticMatches (e.SpecVars)> : e.ExprList
*    = <RenameSignatureVars e.ExprList>;
*}

*PrepareSignature-SortVars {
*  e.StaticMatches (e.SpecPatternVars)
*    = <MapAccum
*        {
*          (e.Vars-B (e.Val ':' (Var e.Index)) e.Vars-E) (e.Index)
*            = (e.Vars-B e.Vars-E) (e.Val);
*
*          /*
*            Если очередной переменной нет среди подстановок, значит
*            она динамическая
*          */
*          (e.Variables) (e.Index) = (e.Variables) /* пропускаем */;
*        }
*        (e.StaticMatches) e.SpecPatternVars
*      >
*    : (/* должно быть пусто */) e.SigValues
*    = e.SigValues;
*}

*RenameSignatureVars {
*  e.Signature
*    = /* пусто */ : e.KnownVars
*    = 0 : s.NextId
*    = <MapAccum
*        {
*          (e.KnownVars^ s.NextId^) (e.SignaturePart)
*            = <RenameSignatureVars-Expr (e.KnownVars s.NextId) e.SignaturePart>
*            : (e.KnownVars^ s.NextId^) e.SignaturePart^
*            = (e.KnownVars s.NextId) (e.SignaturePart);
*        }
*        (e.KnownVars s.NextId)
*        e.Signature
*      >
*    : (e.KnownVars^ s.NextId^) e.Signature^
*    = e.Signature;
*}

RenameSignatureVars-Expr {
  t.State e.Expr = <MapAccum &RenameSignatureVars-Term t.State e.Expr>;
}

RenameSignatureVars-Term {
  (e.KnownVariables s.NextId) (Var s.Mode e.OldIndex)
    , e.KnownVariables : e._B (s.Mode e.OldIndex (e.NewIndex)) e._E
    = (e.KnownVariables s.NextId)
      (Var s.Mode e.NewIndex);

  (e.KnownVariables s.NextId) (Var s.Mode e.OldIndex)
    = <Symb s.NextId> : e.NewIndex
    = (e.KnownVariables (s.Mode e.OldIndex (e.NewIndex)) <Inc s.NextId>)
      (Var s.Mode e.NewIndex);

  t.State (s.BracketsTag e.Expr)
    , <OneOf s.BracketsTag CallBrackets ClosureBrackets Brackets> : True
    = <RenameSignatureVars-Expr t.State e.Expr> : t.State^ e.Expr^
    = t.State (s.BracketsTag e.Expr);

  t.State (ADT-Brackets (e.Name) e.Expr)
    = <RenameSignatureVars-Expr t.State e.Expr> : t.State^ e.Expr^
    = t.State (ADT-Brackets (e.Name) e.Expr);

  t.State t.OtherTerm = t.State t.OtherTerm;
}

/*
  Применяем левую подстановку к левым частям правой.
  Это не совсем композиция подстановок, поскольку для композиции нужно
  также объединять домены подстановок.
*/
ApplySubst-Subst {
  (e.FromSubstitution) e.ToSubstitution
    = <Map
        {
          (e.Expr ':' t.Var)
            = (<ApplySubst-Expr (e.FromSubstitution) e.Expr> ':' t.Var);
        }
        e.ToSubstitution
      >;
}

ApplySubst-Expr {
  (e.Substitution) e.Expression
    = <Map
        {
          (Var e.ModeIndex)
            , e.Substitution : e.Subst-B (e.Value ':' (e.ModeIndex)) e.Subst-E
            = e.Value;

          (Brackets e.Nested)
            = (Brackets <ApplySubst-Expr (e.Substitution) e.Nested>);

          (ADT-Brackets (e.Name) e.Nested)
            = (ADT-Brackets
                (e.Name) <ApplySubst-Expr (e.Substitution) e.Nested>
              );

          (CallBrackets e.Nested)
            = (CallBrackets <ApplySubst-Expr (e.Substitution) e.Nested>);

          (ClosureBrackets e.ClosureContent)
            = (ClosureBrackets
                <ApplySubst-Expr (e.Substitution) e.ClosureContent>
              );

          t.OtherTerm = t.OtherTerm;
        }
        e.Expression
      >;
}

Spec-FindInSignatures {
  (e.Signature)
  e.Signatures-B ((e.InstanceName) e.Signature) e.Signatures-E
    = Found e.InstanceName
      (((e.InstanceName) e.Signature) e.Signatures-B e.Signatures-E);

  (e.Signature) e.Signatures = NotFound e.Signatures;
}

/**
  <IsTrivialSubstitutions e.StaticMatches>
*/
*IsTrivialSubstitutions {
*  e.StaticMatches
*    = <Reduce
*        {
*          False t.Any = False;
*
*          True ((Var s.Mode e.Index1) ':' (Var s.Mode e.Index2))
*            = True;
*
*          True ((Var s.Mode e.Index1) ':' (s.Mode e.Index2))
*            = True;
*
*          True t.OtherSubstitution = False;
*        }
*        True
*        e.StaticMatches
*      >;
*}

*PrepareArgOrPattern {
*  (e.StaticMatches) (e.DynamicMatches) e.SpecPattern
*
*    /*
*      ExtractVariables-Expr сохраняет относительный порядок переменных,
*      однако оставляет дубликаты. Но в e.SpecPattern это не критично,
*      поскольку все переменные в нём должны быть уникальны (иначе
*      синтаксическая ошибка).
*    */
*    = <ExtractVariables-Expr e.SpecPattern> : e.SpecVars
*
*    = <MapAccum
*        {
*          (e.KnownVarsFromStatic) (s.Mode e.Index)
*            , e.StaticMatches
*            : e._B (e.Expr ':' (Var s.Mode e.Index)) e._E
*            = <MapAccum
*                {
*                  (e.KnownVarsFromStatic^) (s.Mode^ e.Index^)
*                    , e.KnownVarsFromStatic : e._B1 (s.Mode e.Index) e._E1
*                    = (e.KnownVarsFromStatic)
*                      /* пропускаем переменную */;
*
*                  (e.KnownVarsFromStatic^) (s.Mode^ e.Index^)
*                    = (e.KnownVarsFromStatic (s.Mode e.Index))
*                      <WrapVar s.Mode (Var s.Mode e.Index)>;
*                }
*                (e.KnownVarsFromStatic)
*                <ExtractVariables-Expr e.Expr>
*              >;
*
*          (e.KnownVarsFromStatic) (s.Mode e.Index)
*            , e.DynamicMatches
*            : e._B (e.Expr ':' (Var s.Mode e.Index)) e._E
*            = (e.KnownVarsFromStatic) <WrapVar s.Mode e.Expr>;
*        }
*        (/* Known vars from static */)
*        e.SpecVars
*      >
*    : (e.KnownVarsFromStatic) e.NewArgOrPattern
*
*    = <RemoveLastGhostBracket e.NewArgOrPattern>;
*}

WrapVar {
  'e' e.Expr = (GhostBrackets e.Expr);
  s.Mode e.Expr = e.Expr
}

RemoveLastGhostBracket {
  e.NewArgOrPattern (GhostBrackets e.LastEValue)
    = <Map
        {
          (GhostBrackets e.Expr) = (Brackets e.Expr);
          t.STValue = t.STValue;
        }
        e.NewArgOrPattern
      >
      e.LastEValue;

  e.NewArgOrPattern t.STValue
    = <RemoveLastGhostBracket e.NewArgOrPattern> t.STValue;

  /* пусто */ = /* пусто */;
}

*RenameGenericMatch {
*  (e.SpecPattern) (e.StaticMatches) e.VarsFromBody
*    = <Map
*        {
*          (e.Val ':' t.Var) = <ExtractVariables-Expr e.Val>;
*        }
*        e.StaticMatches
*      >
*    : e.VarsFromMatch
*
*    = <Unique e.VarsFromMatch> : e.VarsFromMatch^
*
*    = <MapAccum
*        {
*          (e.VarsFromBody^) (e.CurrentVarName)
*            = <NewVarName (e.VarsFromBody) e.CurrentVarName>
*            : (e.VarsFromBody^) e.NewVarName
*            = (e.VarsFromBody)
*              ((Var e.NewVarName) ':' (e.CurrentVarName))
*        }
*        (e.VarsFromBody)
*        e.VarsFromMatch
*      >
*    : (e.VarsFromBody^) e.Renames
*
*    = <ApplySubst-Subst (e.Renames) e.StaticMatches>;
*}

*PrepareSpecializedFuncBody {
*  (e.SpecPattern) (e.StaticMatches) e.Body
*    = <ExtractVariables e.Body> : e.BodyVariables
*
*    = <RenameGenericMatch (e.SpecPattern) (e.StaticMatches) e.BodyVariables>
*    : e.StaticMatches^
*
*    = <Map (&PrepareSpecSentence (e.SpecPattern) (e.StaticMatches)) e.Body>;
*}

*PrepareSpecSentence {
*  (e.SpecPattern) (e.CallStaticMatches)
*  ((e.Pattern) e.Conditions (e.Result))
*    = <GenericMatch-Wrapper (e.Pattern) (e.SpecPattern)>
*    : Clear (e.PatternStaticMatches) (e.PatternDynamicMatches)
*
*    = <MapGenericMatches (e.CallStaticMatches) (e.PatternStaticMatches)>
*    : e.StaticSubstitutions
*
*    = <ApplySubst-Subst (e.StaticSubstitutions) e.PatternDynamicMatches>
*    : e.PatternDynamicMatches^
*
*    = <PrepareArgOrPattern
*        (e.CallStaticMatches) (e.PatternDynamicMatches) e.SpecPattern
*      >
*    : e.Pattern^
*
*    = <PrepareSpecConditions (e.StaticSubstitutions) e.Conditions>
*    : e.Conditions^
*
*    = <ApplySubst-Expr (e.StaticSubstitutions) e.Result> : e.Result^
*
*    = ((e.Pattern) e.Conditions (e.Result));
*}

*PrepareSpecConditions {
*  (e.StaticSubstitutions) e.Conditions
*    = <Map
*        {
*          (Condition (e.Name) (e.ConditionResult) (e.ConditionPattern))
*            = (Condition
*                (e.Name)
*                (<ApplySubst-Expr (e.StaticSubstitutions) e.ConditionResult>)
*                (<ApplySubst-Expr (e.StaticSubstitutions) e.ConditionPattern>)
*              );
*        }
*        e.Conditions
*      >
*}

/*
  Вспомогательные функции модуля
*/

*GenericMatch-Wrapper {
*  (e.Expr) (e.HardExpr)
*    = <GenericMatch (e.Expr) (e.HardExpr)>
*    : {
*        Clear e.VarsMatches
*          = <MapAccum
*              {
*                (e.StaticMatches) (e.Val ':' (e.Var))
*                  , e.Var : s.Mode e.Index
*                  , <IsSpecStaticVar (e.Var)> : True
*                  = (e.StaticMatches (e.Val ':' (Var e.Var)))
*                    /* пусто */;
*
*                (e.StaticMatches) (e.Val ':' (e.Var))
*                  = (e.StaticMatches)
*                    (e.Val ':' (Var e.Var));
*              }
*              (/* for statics */)
*              e.VarsMatches
*            >
*          : (e.StaticMatches) e.DynamicMatches
*          = Clear (e.StaticMatches) (e.DynamicMatches);
*
*        s.OtherResult e.ResultInfo
*          = s.OtherResult e.ResultInfo;
*      };
*}

*IsSpecStaticVar {
*  (s.Mode s.FirstSymbol e.Index)
*    , <Type s.FirstSymbol>
*    : {
*        'Lu' s._ = True;
*        e._ = False;
*      };
*}

*MapGenericMatches {
*  (e.ArgStaticMatches) (e.PatternStaticMatches)
*    = <Reduce
*        {
*          (
*            (e.ArgStaticMatches-B (e.ArgVal ':' t.SpecVar) e.ArgStaticMatches-E)
*            (e.MappedMatches)
*          )
*          ((Var s.Mode e.Index) ':' t.SpecVar)
*            = (
*                (
*                  e.ArgStaticMatches-B (e.ArgVal ':' t.SpecVar)
*                  e.ArgStaticMatches-E
*                )
*                (e.MappedMatches (e.ArgVal ':' (s.Mode e.Index)))
*              );
*        }
*        ((e.ArgStaticMatches) (/* for result */))
*        e.PatternStaticMatches
*      >
*    : ((e._) (e.ResultMatches))
*    = e.ResultMatches;
*}

/*
  Функции, относящиеся к проверке отношения Хигмана-Крускала
*/

/**
  <HasHigmanKruskalRelation (e.Name) (e.Signature) e.History>
    == True e.HistorySignature
    == False

  Функция проверяет, выполняется ли отношение Хигмана-Крускала
  для одной из сигнатур в e.History и сигнатуры e.Signature,
  то есть проверяется, можно ли вложить одну сигнатуру в другую,
  удалив некоторые элементы.
  В случае, если в истории сигнатур удаётся найти сигнатуру,
  для которой выполняется указанное отношение,
  функция возвращает True и соответствующий e.HistorySignature.
  В ином случае возвращается False.
*/
*HasHigmanKruskalRelation {
*  (e.Name) (e.Signature) e.History ((e.InstanceName) e.HistorySignature)
*    , <SourceNameOfInstance e.InstanceName> : e.Name
*    , <OptTree-CheckTupleStopRelation
*        (e.Signature) <OptTree-CanonizeTuple e.HistorySignature>
*      >
*    : True
*    = True e.HistorySignature;
*
*  (e.Name) (e.Signature) e.History ((e.InstanceName) e.HistorySignature)
*    = <HasHigmanKruskalRelation (e.Name) (e.Signature) e.History>;
*
*  (e.Name) (e.Signature) /* пустая история */ = False;
*}

SourceNameOfInstance {
  e.Name SUF '@' s._ = e.Name;
  e.Name '@' s._ = e.Name;
}

/* Выполняет обобщение */
*MakeGeneralization {
*  (e.Signature) (e.HistorySignature) (e.Argument)
*  (e.SpecPattern) (e.StaticMatches) (e.Name)
*  (e.Body) s.NextNumber (e.Signatures) (e.DynamicMatches)
*  (e.History) (e.Calls)
*
*    /* Получаем обобщение двух сигнатур */
*    = <GetSignaturesGeneralization
*        (e.Signature) e.HistorySignature
*      >
*    : e.GenSignature
*
*    /* Находим имеющиеся в аргументе переменные */
*    = <ExtractVariables-Expr e.Argument> : e.ArgumentVars
*
*    /*
*      Присваиваем переменным в сигнатуре имена,
*      отличные от имён переменных в аргументе e.Argument
*    */
*    = <NameSignatureVars (e.ArgumentVars) e.GenSignature> : e.GenStaticMatches
*
*    /* Получаем переменные из e.SpecPattern */
*    = <ExtractVariables-Expr e.SpecPattern> : e.SpecPatternVars
*
*    /*
*      Частям обобщённой сигнатуры приписываем имена статических переменных
*    */
*    = <GetSignaturesGeneralizationMatches
*        (e.SpecPatternVars) e.GenStaticMatches
*      >
*    : e.GenStaticMatches^
*
*    /* Формируем e.RealSubst через GenericMatch */
*    = <GetRealSubst (e.StaticMatches) (e.GenStaticMatches)> : e.RealSubst
*
*    = <IsTrivialSubstitutions e.RealSubst>
*    : {
*        /*
*          Если подстановка e.RealSubst является тривиальной,
*          проверку отношения Хигмана-Крускала
*          в рекурсивном вызове не выполняем
*        */
*        True = False;
*
*        False = True;
*      }
*    : s.NeedRelationCheck
*
*    /* Для e.GenStaticMatches вызываем SpecCall-Matches */
*    = <SpecCall-Matches
*        (e.Name) (e.SpecPattern) (e.Body) s.NextNumber e.Signatures
*        (e.Argument) (e.GenStaticMatches)
*        (e.DynamicMatches) (e.History) s.NeedRelationCheck
*      >
*    : t.Info
*      t.NewCall
*      e.NewFunc
*      (e.NewHistory)
*
*    /* К новому вызову применяем подстановку*/
*    = <ApplySubst-Expr (e.RealSubst) t.NewCall> : t.NewCall^
*    = <ApplySubst-Expr (e.Calls) t.NewCall> : t.NewCall^
*
*    = t.Info
*      t.NewCall
*      e.NewFunc
*      (e.NewHistory);
*}

/*
  Назначает имена переменным в сигнатуре,
  отличные от тех, что есть в e.KnownVars.
*/
*NameSignatureVars {
*  (e.KnownVars) e.Signature
*    = <MapAccum
*        {
*          (e.KnownVars^) (e.SignaturePart)
*            = <NameSignatureVars-Expr (e.KnownVars) e.SignaturePart>
*            : (e.KnownVars^) e.SignaturePart^
*            = (e.KnownVars) (e.SignaturePart);
*        }
*        (e.KnownVars)
*        e.Signature
*      >
*    : (e.KnownVars^) e.Signature^
*    = e.Signature;
*}

*NameSignatureVars-Expr {
*  t.State e.Expr = <MapAccum &NameSignatureVars-Term t.State e.Expr>;
*}

*NameSignatureVars-Term {
*  (e.KnownVars) (Var s.Mode)
*    = <NewVarName (e.KnownVars) s.Mode 'X'> : (e.KnownVars^) e.Index
*    = (e.KnownVars)
*      (Var e.Index);
*
*  t.State (s.BracketsTag e.Expr)
*    , <OneOf s.BracketsTag CallBrackets ClosureBrackets Brackets> : True
*    = <NameSignatureVars-Expr t.State e.Expr> : t.State^ e.Expr^
*    = t.State (s.BracketsTag e.Expr);
*
*  t.State (ADT-Brackets (e.Name) e.Expr)
*    = <NameSignatureVars-Expr t.State e.Expr> : t.State^ e.Expr^
*    = t.State (ADT-Brackets (e.Name) e.Expr);
*
*  t.State t.OtherTerm = t.State t.OtherTerm;
*}

/*
  Получает обобщённую сигнатуру для двух сигнатур.
  Перебирает статические переменные сигнатур по очереди.
*/
*GetSignaturesGeneralization {
*  (t.Sig1-StaticVarPart e.Sig1-Rest) t.Sig2-StaticVarPart e.Sig2-Rest
*    = (<GlobalGen t.Sig1-StaticVarPart t.Sig2-StaticVarPart>)
*      <GetSignaturesGeneralization (e.Sig1-Rest) e.Sig2-Rest>;
*
*  (/* пусто */) /* пусто */
*    = /* пусто */;
*}

/*
  Возвращает соответствия между статическими переменными и
  частями обобщённой сигнатуры
*/
*GetSignaturesGeneralizationMatches {
*  (t.Var e.Vars) (e.GenSignature-First) e.GenSignature-E
*    = <IsSpecStaticVar t.Var>
*    : {
*        True
*          , t.Var : (e.VarInner)
*          = (e.GenSignature-First ':' (Var e.VarInner))
*            <GetSignaturesGeneralizationMatches
*              (e.Vars) e.GenSignature-E
*            >;
*
*        False
*          = <GetSignaturesGeneralizationMatches
*              (e.Vars) (e.GenSignature-First) e.GenSignature-E
*            >;
*      };
*
*  e.OtherExpr
*    = /* пусто */;
*}

*GetRealSubst {
*  (e.StaticMatches-B (e.Val1 ':' (Var e.Var)) e.StaticMatches-E)
*  (e.GenStaticMatches-B (e.Val2 ':' (Var e.Var)) e.GenStaticMatches-E)
*    = <GenericMatch (e.Val1) (e.Val2)>
*    : {
*        Clear e.Expr
*          = e.Expr
*            <GetRealSubst
*              (e.StaticMatches-B e.StaticMatches-E)
*              (e.GenStaticMatches-B e.GenStaticMatches-E)
*            >;
*
*        e.Other
*          = <GetRealSubst
*              (e.StaticMatches-B e.StaticMatches-E)
*              (e.GenStaticMatches-B e.GenStaticMatches-E)
*            >;
*      };
*
*  e.OtherExpr
*    = /* пусто */;
*}

/*
  Новая реализация специализации
*/

/* TODO: документация функций */

SpecCall {
  (e.Name) (e.SpecPattern) (e.Body) s.NextNumber e.Signatures
  (e.Argument) (e.History)
    /*
      Приводим аргумент к пассивному виду и переименовываем
      переменные в теле функции, чтобы они не пересекались с
      переменными в аргументе
    */
    = <ExtractVariables ((e.Argument) (/* пусто */))> : e.UsedVars
    = <ExtractCalls-Expr (/* пусто */ (e.UsedVars)) e.Argument>
    : (e.Sg (e.UsedVars^)) e.NewArgument
    = <RenameVars-Sentences (e.UsedVars) e.Body> : e.Body^
    /* ищем динамическое обобщение для аргумента и образцов */
    = <DynGenArg
        (e.NewArgument) (e.Sg) (/* пусто */)
        (/* пусто */) e.Body
      >
    : (e.NewArgument^) (e.Sg^) (e.Solutions)
    = <SpecCall-Aux
        (e.Name) (e.SpecPattern) (e.Body) s.NextNumber e.Signatures
        (e.Argument) (e.NewArgument) (e.Sg) (e.Solutions) (e.History)
      >;
}

RenameVars-Sentences {
  (e.KnownVars) ((e.Pattern) e.Tail) e.Sentences
    = (
        (<RenameVars-Expr (e.KnownVars) e.Pattern>)
        <RenameVars-Tail (e.KnownVars) e.Tail>
      )
      <RenameVars-Sentences (e.KnownVars) e.Sentences>;

  (e.KnownVars) /* пусто */ = /* пусто */;
}

RenameVars-Tail {
  (e.KnownVars) (Condition (e.ConditionName) (e.Result) (e.Pattern)) e.Tail
    = (
        Condition (e.ConditionName)
        (<RenameVars-Expr (e.KnownVars) e.Result>)
        (<RenameVars-Expr (e.KnownVars) e.Pattern>)
      )
      <RenameVars-Tail (e.KnownVars) e.Tail>;

  (e.KnownVars) (e.Result) = (<RenameVars-Expr (e.KnownVars) e.Result>);
}

RenameVars-Expr {
  (e.KnownVars) (Var e.ModeIndex) e.Terms
    = <NewVarName (e.KnownVars) e.ModeIndex> : (e.KnownVars^) e.New
    = (Var e.New) <RenameVars-Expr (e.KnownVars) e.Terms>;

  (e.KnownVars) (s.BracketsTag e.Inner) e.Terms
    , <OneOf s.BracketsTag CallBrackets ClosureBrackets Brackets> : True
    = (s.BracketsTag <RenameVars-Expr (e.KnownVars) e.Inner>)
      <RenameVars-Expr (e.KnownVars) e.Terms>;

  (e.KnownVars) (ADT-Brackets (e.Name) e.Inner) e.Terms
    = (ADT-Brackets (e.Name) <RenameVars-Expr (e.KnownVars) e.Inner>)
      <RenameVars-Expr (e.KnownVars) e.Terms>;

  (e.KnownVars) t.Other e.Terms
    = t.Other <RenameVars-Expr (e.KnownVars) e.Terms>;

  (e.KnownVars) /* пусто */ = /* пусто */;
}

DynGenArg {
  (e.Arg) (e.Sg) (e.Sol) (e.Begin)
  ((e.Pat) e.Tail) e.Sentences
    = <ExtractVariables ((e.Arg e.Pat) (/* пусто */))> : e.UsedVars
    = <Solve-Spec (e.UsedVars) (e.Arg) (e.Pat)>
    : {
        Success e.Solutions (e.SgNew) (e.ArgNew)
          , e.SgNew : /* пусто */
          = <DynGenArg
              (e.Arg) (e.Sg) (e.Sol (e.Solutions))
              (e.Begin ((e.Pat) e.Tail)) e.Sentences
            >;

        Success e.Solutions (e.SgNew) (e.ArgNew)
          = <DynGenArg
              (e.ArgNew) (<ApplySubst-Subst (e.Sg) e.SgNew>)
              (/* пусто */) (/* пусто */)
              e.Begin ((e.Pat) e.Tail) e.Sentences
            >;

        /* возвращаем тривиальную сигнатуру */
        Failure = ((Var 'e')) (/* пусто */) (/* пусто */);
      };

  (e.Arg) (e.Sg) (e.Sol) (e.Begin)
    = (e.Arg) (e.Sg) (e.Sol);
}

SpecCall-Aux {
  /* тривиальная сигнатура */
  (e.Name) (e.SpecPattern) (e.Body) s.NextNumber e.Signatures
  (e.OldArg) (e.NewArg) (e.Sg) (e.Solutions) (e.History)
    , <IsTrivialSignature e.NewArg> : True
    = ((e.SpecPattern) (e.Body) s.NextNumber e.Signatures)
      (CallBrackets (Symbol Name e.Name) e.OldArg)
      /* пусто */ (/* пусто */);

  /* проверяем, известна ли сигнатура */
  (e.Name) (e.SpecPattern) (e.Body) s.NextNumber e.Signatures
  (e.OldArg) (e.NewArg) (e.Sg) (e.Solutions) (e.History)
    = <RenameSignatureVars-Expr (/* пусто */ 0) e.NewArg>
    : t.State e.Signature
    = <Spec-FindInSignatures (e.Signature) e.Signatures>
    : {
        Found e.InstanceName (e.Signatures^)
          = ((e.SpecPattern) (e.Body) s.NextNumber e.Signatures)
            (CallBrackets
              (Symbol Name e.InstanceName)
              <ApplySubst-Expr (e.Sg) <WrapVars e.NewArg>>
            )
            /* пусто */ (/* пусто */);

        /* проверяем на зацикливание */
        NotFound e.Signatures^
          = <HasHigmanKruskalRelation
              (e.Name) (<OptTree-CanonizeExpr e.Signature>)
              e.History
            >
          : {
              True e.HistorySignature
                = <GlobalGen (e.Signature) (e.HistorySignature)> : e.GenSignature
                = <ExtractVariables ((e.NewArg) (/* пусто */))> : e.ArgVars
                = <RenameVars-Expr (e.ArgVars) e.GenSignature> : e.GenSignature^
                = <GenericMatch (e.NewArg) (e.GenSignature)>
                : {
                    Clear e.NewSg = e.NewSg;

                    e.Other = /* пусто */;
                  }
                : e.NewSg
                = <SpecCall-Aux
                    (e.Name) (e.SpecPattern) (e.Body) s.NextNumber
                    e.Signatures (e.OldArg) (e.GenSignature)
                    (<ApplySubst-Subst (e.Sg) e.NewSg>)
                    (e.Solutions) (e.History)
                  >;

              False
                = <CreateNewSentences
                    (e.NewArg) (/* пусто */)
                    (e.Solutions) (e.Body)
                  >
                : e.NewSentences
                = <AddSuffix e.Name ('@' s.NextNumber)> : e.InstanceName
                = (
                    (e.SpecPattern) (e.Body) <Inc s.NextNumber>
                    e.Signatures ((e.InstanceName) e.Signature)
                  )
                  (CallBrackets
                    (Symbol Name e.InstanceName)
                    <ApplySubst-Expr (e.Sg) <WrapVars e.NewArg>>
                  )
                  (Function
                    GN-Local (e.InstanceName)
                    Sentences e.NewSentences
                  )
                  (
                    (
                      (e.InstanceName) e.History
                      ((e.InstanceName) e.Signature)
                    )
                  );
            }
      };
}

IsTrivialSignature {
  e.Arg, e.Arg : (Var 'e' e._) = True;

  e.Arg = False;
}

WrapVars {
  e.Arg
    = <ExtractVariables-Expr e.Arg> : e.UsedVars
    = <OrderUniqueVars e.UsedVars> : e.UsedVars^
    = <Map
        { (s.Mode e.Index) = <WrapVar s.Mode (Var s.Mode e.Index)> }
        e.UsedVars
      >
    : e.UsedVars^
    = <RemoveLastGhostBracket e.UsedVars>
}

OrderUniqueVars {
  e.Vars
    = <Reduce
        {
          (e.UniqueVars) (e.ModeIndex)
            , e.UniqueVars : e.Begin (e.ModeIndex) e.End
            = (e.UniqueVars);

          (e.UniqueVars) (e.ModeIndex)
            = (e.UniqueVars (e.ModeIndex));
        }
        (/* пусто */)
        e.Vars
      >
    : (e.Vars^)
    = e.Vars;
}

HasHigmanKruskalRelation {
  (e.Name) (e.Signature) e.History ((e.InstanceName) e.HistorySignature)
    , <SourceNameOfInstance e.InstanceName> : e.Name
    , <OptTree-CheckExprStopRelation
        (e.Signature) <OptTree-CanonizeExpr e.HistorySignature>
      >
    : True
    = True e.HistorySignature;

  (e.Name) (e.Signature) e.History ((e.InstanceName) e.HistorySignature)
    = <HasHigmanKruskalRelation (e.Name) (e.Signature) e.History>;

  (e.Name) (e.Signature) /* пустая история */ = False;
}

CreateNewSentences {
  (e.Arg) (e.NewSentences)
  ((e.Sol) e.Solutions) (((e.Pat) e.Tail) e.Body)
    = <Reduce
        {
          (e.NewSentences^) ((e.Contrs) (e.Assigns))
            = <FormatContractions e.Contrs> : e.Contrs^
            = <FormatAssigns e.Assigns> : e.Assigns^
            = (
                e.NewSentences
                (
                  (<ApplySubst-Expr (e.Contrs) <WrapVars e.Arg>>)
                  <ApplySubst-Tail (e.Assigns) e.Tail>
                )
              )
        }
        (e.NewSentences)
        e.Sol
      >
    : (e.NewSentences^)
    = <CreateNewSentences
        (e.Arg) (e.NewSentences)
        (e.Solutions) (e.Body)
      >;

  (e.Arg) (e.NewSentences)
  (/* пусто */) (/* пусто */)
    = e.NewSentences;
}

FormatContractions {
  ((Var e.ModeIndex) ':' e.Val) e.Contrs
    = (e.Val ':' (e.ModeIndex)) <FormatContractions e.Contrs>;

  /* пусто */ = /* пусто */;
}

FormatAssigns {
  (e.Val ':' (Var e.ModeIndex)) e.Assigns
    = (e.Val ':' (e.ModeIndex)) <FormatAssigns e.Assigns>;

  /* пусто */ = /* пусто */;
}

ApplySubst-Tail {
  (e.Substitution) (Condition (e.ConditionName) (e.Result) (e.Pattern)) e.Tail
    = (
        Condition (e.ConditionName)
        (<ApplySubst-Expr (e.Substitution) e.Result>)
        (<ApplySubst-Expr (e.Substitution) e.Pattern>)
      )
      <ApplySubst-Tail (e.Substitution) e.Tail>;

  (e.Substitution) (e.Result)
    = (<ApplySubst-Expr (e.Substitution) e.Result>);
}
