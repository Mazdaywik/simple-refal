
//FROM LibraryEx
$EXTERN UnBracket, Map, Fetch, Seq, Inc, Dec, Compare;

//FROM Library
$EXTERN Add, Sub, WriteLine;

//FROM FastGen
$EXTERN FastGen-Terms, CreateFastGen, ModifyE, ModifyBrackets;


$ENTRY CreateGlobalGen {
  e.HardSentences =
    <Fetch
      <CreateFastGen e.HardSentences>
      <Seq
        {e.all = e.all <WriteLine 'CGG1\n' e.all>;}
        {(e.FastGen) = (e.FastGen)(<InspectFastGen e.FastGen>);}
        {e.all = e.all <WriteLine 'CGG2\n' e.all>;}
        {
          (e.FastGen)(e.Inspected) =
            (e.FastGen)
            (<GlobalGen e.Inspected>);
        }
      >
    >;
}

InspectFastGen {
  (#E '$' e.EReplacements ) e.Tail =
    <WriteLine 'IFG1\n' (#E '$' e.EReplacements )>
    (#E 
      <Fetch
        <ReplacmentsCounter 0 () e.EReplacements>
        {
          1 = 1;
          s.Num = 0;
        }
      >
      '$'
      e.EReplacements
    )
    <InspectFastGen e.Tail>;
  (#Brackets e.inBrackets) e.Tail =
    <WriteLine 'IFG2\n' (#Brackets e.inBrackets)>
    (#Brackets  <InspectFastGen e.inBrackets>) <InspectFastGen e.Tail>;
  (e.Any) e.Tail = <WriteLine 'IFG3\n' e.Any> (e.Any) <InspectFastGen e.Tail>;
   = ;
}

ReplacmentsCounter {
  s.Counter (e.Scanned) ((e.Replacement)) e.Tail =
    <WriteLine 'RC\n' s.Counter (e.Scanned) ((e.Replacement)) e.Tail>
    <Fetch
      <InList (<PrepRep e.Replacement>) (e.Scanned)>
      {
        0 (e.PrepReplacement) =
          <ReplacmentsCounter <Inc s.Counter> (e.Scanned (e.PrepReplacement)) e.Tail>;
        1 (e.PrepReplacement) = <ReplacmentsCounter s.Counter (e.Scanned) e.Tail>;
      }
    >;
  s.Counter (e.Scanned) = s.Counter;
}

PrepRep {
  (#Atom e.Body) e.Tail = (#Atom e.Body) <PrepRep e.Tail>;
  (#Brackets e.inBrackets) e.Tail = 
    ( #Brackets <PrepRep e.inBrackets> ) <PrepRep e.Tail>;
  (s.Mode e.Body) e.Tail = (s.Mode) <PrepRep e.Tail>;
  (e.Else) e.Tail = (e.Else) <PrepRep e.Tail>;
   = ;
}

InList {
  (e.Elem) () = 0 (e.Elem);
  (e.Elem) (t.ListElem e.List) = 
    <Fetch
      <Compare (t.ListElem) (e.Elem)>
      {
        '=' = 1 ();
        s.Else = <InList (e.Elem) (e.List)>;
      }
    >;
}


GlobalGen {
  /* empty */ = ();
  e.Inspected =
    <WriteLine 'Inspected\n' e.Inspected>
    <Map
      {
        (#E 0 '$' e.Body) = <GlobalGen-Aux e.Body>;
        (#E 1 '$' e.Body) = (#E '$' e.Body);
        (#Brackets e.inBrackets) =
          (#Brackets <GlobalGen e.inBrackets>);
        (e.Any) = (e.Any);
      }
      e.Inspected
    >;
}

GlobalGen-Aux {
  e.Replacements =
    <Fetch
      <Map
        {((e.Replacement)) = (e.Replacement);}
        e.Replacements
      >
      <Seq
        {
          e.All =
            <GetComplex
              <Map
                { ((e.Class) e.Body) = <CalcComplexity <Generalization e.Body>>; }
                <CreateSuperposition 
                  (e.All)
                  (<ComputePossibleClasses e.All>)
                >
              >
            >;
        }
      >
    >;
}

GetPatterns {
  (e.FastGenReps) =
    <ModifyE <ModifyBrackets e.FastGenReps>>;
}

ComputePossibleClasses {
  e.Patterns = 
    <Fetch
      e.Patterns
      <Seq
        ComputeClasses
        {e.Classes = <GetMinKMN (100 100 100) e.Classes>;}
        ComputePossibleClasses-Aux
      >
    >;
}

ComputeClasses {
  e.Patterns =
    <Map
      {
        (e.Left (#E e.Body) e.Right) =
          (#MN <ComputeClassMN e.Left (#E e.Body) e.Right 0 0>);
        (e.Pattern) = (#K <ComputeClassK e.Pattern 0>);
      }
      e.Patterns
    >;
}

GetMinKMN {
  (s.K s.M s.N) (#K s.KNum) e.OtherClasses =
    <GetMinKMN (<Min s.K s.KNum> s.M s.N) e.OtherClasses>;
  (s.K s.M s.N) (#MN s.MNum s.NNum) e.OtherClasses =
    <GetMinKMN (s.K <Min s.M s.MNum> <Min s.N s.NNum>) e.OtherClasses>;
  (s.K s.M s.N) = (s.K s.M s.N);
}

ComputePossibleClasses-Aux {
  (s.K 100 100) = <GetClasses 0 s.K s.K>;
  (100 s.M s.N) = (s.M s.N);
  (s.K s.M s.N) = 
    <Fetch
      <Compare s.K <Add s.M s.N>>
      <Compare s.K s.M>
      <Compare s.K s.N>
      {
        '>' e.Tail = (s.M s.N);
        '=' e.Tail = (s.M s.N);
        '<' '>' '>' =
          (<GetClasses
            <Min <Sub s.K s.N> s.M>
            <Max <Sub s.K s.N> s.M>
            s.K
          >);
        '<' '>' '=' = <GetClasses 0 s.M s.K>;
        '<' '>' '<' = <GetClasses 0 s.M s.K>;
        
        '<' '<' '>' = <GetClasses <Sub s.K s.N> s.K s.K>;
        '<' '<' '=' = <GetClasses 0 s.K s.K>;
        '<' '<' '<' = <GetClasses 0 s.K s.K>;
        
        '<' '=' '>' = <GetClasses <Sub s.K s.N> s.K s.K>;
        '<' '=' '=' = <GetClasses 0 s.K s.K>;
        '<' '=' '<' = <GetClasses 0 s.K s.K>;
      }
    >;
}

/* (M, MplusN - M) till M <= MaxM */
GetClasses {
  s.M s.MaxM s.MplusN =
    <Fetch
      <Compare s.M s.MaxM>
        {
          '>' = ;
          s.Else = (s.M <Sub s.MplusN s.M>) <GetClasses <Inc s.M> s.MaxM s.MplusN>;
        }
    >;
}

ComputeClassK {
  s.K = s.K;
  t.Term e.Tail s.K = <ComputeClassK e.Tail <Inc s.K>>;
}

ComputeClassMN {
  (#E e.Body) s.M s.N = s.M s.N;
  (#E e.Body1) e.Any (#E e.Body2) s.M s.N = s.M s.N;
  (#E e.Body) e.Any t.Right s.M s.N =
    <ComputeClassMN (#E e.Body) e.Any s.M <Inc s.N>>;
  t.Left e.Any (#E e.Body) s.M s.N =
    <ComputeClassMN e.Any (#E e.Body) <Inc s.M> s.N>;
  t.Left e.Any t.Right s.M s.N =
    <ComputeClassMN e.Any <Inc s.M> <Inc s.N>>;
}

Superposition {
  () (s.Num1 s.Num2) = (#E '$' (()) );
  (e.Any) (0 0) = (#E '$' ((e.Any)));
  
  ((#Brackets e.inBrackets) e.Tail)(s.Num1 0) = 
    (#Brackets e.inBrackets) <Superposition (e.Tail) (<Dec s.Num1> 0)>;
  ((#Atom e.Body) e.Tail)(s.Num1 0) = 
    (#Atom e.Body) <Superposition (e.Tail) (<Dec s.Num1> 0)>;
  ((#S e.Body) e.Tail)(s.Num1 0) = 
    (#S e.Body) <Superposition (e.Tail) (<Dec s.Num1> 0)>;
  ((#T e.Body) e.Tail)(s.Num1 0) = 
    (#T e.Body) <Superposition (e.Tail) (<Dec s.Num1> 0)>;
    
  (e.Head (#Brackets e.inBrackets)) (s.Num1 s.Num2) =
    <Superposition (e.Head) (s.Num1 <Dec s.Num2>)> (#Brackets e.inBrackets);
  (e.Head (#Atom e.Body)) (s.Num1 s.Num2) =
    <Superposition (e.Head) (s.Num1 <Dec s.Num2>)> (#Atom e.Body);
  (e.Head (#S e.Body)) (s.Num1 s.Num2) =
    <Superposition (e.Head) (s.Num1 <Dec s.Num2>)> (#S e.Body);
  (e.Head (#T e.Body)) (s.Num1 s.Num2) =
    <Superposition (e.Head) (s.Num1 <Dec s.Num2>)> (#T e.Body);
}

CreateSuperposition-Aux {
  ((e.Pattern) e.Tail) (e.Class) =
    (<Superposition (e.Pattern) (e.Class)>)
    <CreateSuperposition-Aux (e.Tail) (e.Class)>;
  () (e.Class) = ;
}

CreateSuperposition {
  (e.Patterns) ((e.Class) e.Tail) =
    ((e.Class) <CreateSuperposition-Aux (e.Patterns)(e.Class)>)
    <CreateSuperposition (e.Patterns) (e.Tail)>;
  (e.Patterns) () = ;
}

Generalization-Aux {
  (t.Term1 e.Tail1)(t.Term2 e.Tail2) =
    <FastGen-Terms (t.Term1)(t.Term2)>
    <Generalization-Aux (e.Tail1)(e.Tail2)>;
  ((#E e.Pattern ))() = (#E '$' (e.Pattern) ());
  ()((#E e.Pattern )) = (#E '$' () (e.Pattern));
  ()() = ;
}

Generalization {
  (e.Pattern1)(e.Pattern2) e.Tail =
    <Generalization
      (<Generalization-Aux (e.Pattern1)(e.Pattern2)>)
      e.Tail
    >;
  (e.Pattern) = (e.Pattern);
}

CalcComplexity-aux {
  s.Comp (#S e.Body) e.Tail =
    <CalcComplexity-aux <Add s.Comp 2> e.Tail>;
  s.Comp (#E e.Body) e.Tail =
    <CalcComplexity-aux <Sub s.Comp 1> e.Tail>;
  s.Comp (#T e.Body) e.Tail =
    <CalcComplexity-aux <Add s.Comp 1> e.Tail>;
  s.Comp (#Atom e.Body) e.Tail =
    <CalcComplexity-aux <Add s.Comp 3> e.Tail>;
  s.Comp (#Brackets e.Body) e.Tail =
    <CalcComplexity-aux <Add s.Comp 3> e.Body e.Tail>;
  s.Comp = s.Comp;
}

CalcComplexity {
  (e.Body) e.Tail =
    (<CalcComplexity-aux 1 e.Body> e.Body)
    <CalcComplexity e.Tail>;
  = ;
}

GetComplex {
    (s.CurComplexity e.CurBody)(s.Complexity e.Body) e.Tail =
     <Fetch
       <Compare s.CurComplexity s.Complexity>
       {
         '>' = <GetComplex (s.CurComplexity e.CurBody) e.Tail>;
         s.Any = <GetComplex (s.Complexity e.Body) e.Tail>;
       }
     >;
     (s.CurComplexity e.CurBody) = e.CurBody;
}


$ENTRY PatternComment {
  () = ;
  e.Pattern =
    <Map
      {
        (#Atom #TkChar s.Char) e.Tail = '\'' s.Char '\'' <PatternComment e.Tail>;
        (#Atom #TkNumber s.Value) e.Tail = s.Value <PatternComment e.Tail>;
        (#Atom #TkName e.Name) e.Tail = '&' e.Name <PatternComment e.Tail>;
        (#Atom #TkIdentifier e.Ident) e.Tail = '\"' e.Ident '\"' <PatternComment e.Tail>;
        (#Brackets e.inBrackets) e.Tail =
          (<PatternComment e.inBrackets>) <PatternComment e.Tail>;
        (s.Tag e.Any) e.Tail = s.Tag <PatternComment e.Tail>;
      }
      e.Pattern
    >;
}

$ENTRY ReverseGen {
  (#Brackets e.inBrackets) e.Tail = 
    (#Brackets <ReverseGen e.inBrackets>) <ReverseGen e.Tail>;
  (#Atom s.Type e.Value) e.Tail = (s.Type e.Value) <ReverseGen e.Tail>;
  (s.Mode (e.Name) e.Any) e.Tail =
    (#TkVariable <Fetch s.Mode { #E = 'e'; #T = 't'; #S = 's'; }> e.Name)
    <ReverseGen e.Tail>;
  (e.Else) e.Tail = (e.Else) <ReverseGen e.Tail>;
  /* empty */ = /* empty */;
}

$ENTRY ReversePattern {
  (s.Mode (e.name) '$' e.Replacements) e.Tail =
    (s.Mode (e.name) '$' <ReversePattern-Aux e.Replacements>)
    <ReversePattern e.Tail>;
  /* empty */ = /* empty */;
}

ReversePattern-Aux {
  (#Atom s.Type e.Value) e.Tail = (s.Type e.Value) <ReversePattern-Aux e.Tail>;
  (#Brackets e.inBrackets) e.Tail = 
    ( #Brackets <ReversePattern-Aux e.inBrackets> ) <ReversePattern-Aux e.Tail>;
  (s.Mode (e.Name) e.Any) e.Tail =
    (#TkVariable <Fetch s.Mode { #E = 'e'; #T = 't'; #S = 's'; }> e.Name)
    <ReversePattern-Aux e.Tail>;
  (s.Mode '$' ((e.Rep)) e.Any) e.Tail =
    <ReversePattern-Aux e.Rep>
    <ReversePattern-Aux e.Tail>;
  (e.Else) e.Tail = (<ReversePattern-Aux e.Else>) <ReversePattern-Aux e.Tail>;
   = ;
}

$ENTRY SplitGen {
  (()) = ()();
  (e.Any) =
    <Fetch
      e.Any
      <Seq
        { e.All = <DoSplitGen ('idx') e.All>; }
        {
          e.All =
            <GetGeneralization () e.All>
            <GetReplacement e.All>;
        }
      >
    >;
}

DoSplitGen {
  (e.Idx)(s.Mode '$' e.Replacements) e.Tail =
    (s.Mode (e.Idx 0) '$' e.Replacements)
    <DoSplitGen (e.Idx 'V') e.Tail>;
  (e.Idx)(#Brackets e.inBrackets) e.Tail =
    (#Brackets <DoSplitGen (e.Idx 'B') e.inBrackets>)
    <DoSplitGen (e.Idx 'T') e.Tail>;
  (e.Idx)(e.Any) e.Tail =
    (e.Any) <DoSplitGen (e.Idx 'A') e.Tail>;
  (e.Idx) = ;
}

GetGeneralization {
  (e.Scanned) (s.gen (e.name)'$' ((e.rep)) e.reps) e.Tail =
    <GetGeneralization (e.Scanned (s.gen (e.name))) e.Tail>;
  (e.Scanned) (#Brackets e.inBrackets) e.Tail =
    <GetGeneralization (e.Scanned (#Brackets <UnBracket <GetGeneralization () e.inBrackets>>)) e.Tail>;
  (e.Scanned) (e.gen) e.Tail = <GetGeneralization (e.Scanned (e.gen)) e.Tail>;
  (e.Scanned) = (e.Scanned);
}

GetReplacement-Aux {
  (s.Mode (e.Name) '$') e.Tail = ;
  (#Brackets e.Replacements) e.Tail (e.Scanned) (e.Else) =
    <GetReplacement-Aux e.Replacements e.Tail (e.Scanned) (e.Else)>;
  (s.Mode (e.Name) '$' ((e.rep)) e.otherRep ) e.Tail (e.Scanned) (e.Else) =
    <GetReplacement-Aux
      e.Tail 
      (e.Scanned (s.Mode (e.Name) '$' e.rep))
      (e.Else (s.Mode (e.Name) '$' e.otherRep))
    >;
  (s.Mode e.gen) e.Tail (e.Scanned) (e.Else) =
    <GetReplacement-Aux e.Tail (e.Scanned) (e.Else)>;
  (/*Scanned*/) (/*Else*/) = ();
  (e.Scanned) (e.Else) =
    <WriteLine 'reverse\n' e.Scanned>
    (<ReversePattern e.Scanned>) <GetReplacement e.Else>;
}

GetReplacement {
  e.All =
    <GetReplacement-Aux e.All (/*Scanned*/) (/*Else*/)>;
}

/*
  Min and Max of two s-variables
  'Compare' from LibraryEx.sref should work with this variables
*/

$ENTRY Min {
  s.1 s.2 =
    <Fetch
      <Compare s.1 s.2>
      {
        '<' = s.1;
        s.Other = s.2;
      }
    >;
}

$ENTRY Max {
  s.1 s.2 =
    <Fetch
      <Compare s.1 s.2>
      {
        '>' = s.1;
        s.Other = s.2;
      }
    >;
}