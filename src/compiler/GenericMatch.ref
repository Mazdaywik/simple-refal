$INCLUDE "LibraryEx";

*$FROM TreeUtils
$EXTERN ExtractVariables, NewVarName;


/**
  <GenericMatch (e.Pattern) (e.LPattern)>
    == Clear (e.Val ':' t.Var)*
    == Contracted ((t.Var ':' e.Val)* (e.Val ':' t.Var))*
    == Failure
    == Undefined

  e.Pattern, e.LPattern ::= t.PatternTerm*
  t.PatternTerm — см. src/compiler/README.md

  e.Val ::= t.PatternTerm*
  t.Var ::= (s.VarType e.Index)
  s.VarType ::= 's' | 't' | 'e'
*/

FormatAssigns {
  e.Assigns =
    <Map
      {
        (e.Left ':' (Var e.Index)) = (e.Left ':' (e.Index))
      }
      e.Assigns
    >
}

$ENTRY GenericMatch {
  (e.Pattern) (e.LPattern)
    = <Solve-Drive
        (<ExtractVariables ((e.Pattern e.LPattern) (/* пусто */))>)
        ((e.Pattern) ':' (e.LPattern))
      >
    : {
        Success (() (e.Assigns)) = Clear <FormatAssigns e.Assigns>;
        Success e.Solutions = Contracted e.Solutions;
        Failure = Failure;
        Undefined = Undefined;
      }
}

IsSVarSubset {
  (Symbol s.Type e.Info) = True;
  (Var 's' e.Tindex) = True;
  (Closure e.Body) = True;
  (ClosureBrackets e.Context) = True;

  t.OtherTerm = False;
}

/*
  <Solve-Drive (e.UsedVars) t.Equation>
    == Success t.Result* | Undefined | Failure

    t.Contr ::= (t.Var ':' e.Val)
    t.Equation ::= ((e.Expr) ':' (e.LExpr))
    t.Assign ::= (e.Val ':' t.Var)
    t.Result ::= ((t.Contr*) (t.Assign*))
*/

$ENTRY Solve-Drive {
  (e.UsedVars) ((e.Expr) ':' (e.Lexpr))
    = <Solve-Aux (e.UsedVars) () ((e.Expr) ':' (e.Lexpr)) ()>
    : {
      = Failure;
      e.B Undefined e.A = Undefined;
      e.Other = Success <CombineResults () e.Other>
    };
}

$ENTRY Solve-Spec {
  (e.UsedVars) ((e.Expr) ':' (e.LExpr))
    = <AddCoordinateLabels e.Expr> : e.NewExpr
    = <Solve-Aux-Spec
        (e.UsedVars) ()
        ((e.NewExpr) ':' (e.LExpr)) ()
      >;
}

/* Преобразует формат результата функции Solve-Aux к формату Solve-Drive */

CombineResults {
  (e.Solutions) Success (e.Contrs) (e.Assigns) e.Rest
    = <CombineResults (e.Solutions ((e.Contrs) (e.Assigns))) e.Rest>;
  (e.Solutions) /* пусто */ = e.Solutions
}

Eq {
  (e.X) (s.X) = True;
  e.Other = False
}

/*
  Проверка наличия повторных переменных в присваиваниях
  <HasRepeatedVarsAssigns (t.Assign*) (t.Rvar*)>
    == True | False
*/

HasRepeatedVarsAssigns {
  (e.B (e.Expr ':' t.Var) e.M) (e.L t.Var e.R) = True;
  (e.Lexpr) (e.RVars) = False
}

/* Постобработка результатов решения уравнений

    <Solution-PostProcess Success (t.Contraction*) (t.Assign*)>
      == Success (t.Contraction*) (t.Assign*) | Undefined
*/

Solution-PostProcess {
  /*
    если есть идентичные присваивания, то удалаяем их
  */
  (e.Contractions) (e.Assigns)
    , e.Assigns
    : e.B (e.Expr ':' (Var e.HIndex)) e.M (e.Expr ':' (Var e.HIndex)) e.E
    = <Solution-PostProcess
        (e.Contractions)
        (e.B (e.Expr ':' (Var e.HIndex)) e.M e.E)
      >;

  /*
    Если есть непротиворечивые присваивания вида:
    (s.A <- v.B) и (s.C <- v.B) то добавляется сужение (s.C -> v.A)
    и второе присваивание удаляется
  */

  (e.Contractions) (e.Assigns)
    , e.Assigns
    : e.B
      ((Var 's' e.Index1) ':' (Var e.HIndex))
      e.M
      ((Var 's' e.Index2) ':' (Var e.HIndex))
      e.E
    = <Solution-PostProcess
        <AddContraction
          ((Var 's' e.Index2) ':' (Var 's' e.Index1))
          (e.Contractions)
          (e.B ((Var 's' e.Index1) ':' (Var e.HIndex)) e.M e.E)
        >
      >;

  /*
    Если есть присваивания вида:
    (s.A <- v.B) и (X <- v.B) то добавляем сужение (v.A -> X)
    и удаляем первое присваивание
  */

  (e.Contractions) (e.Assigns)
    , e.Assigns
    : e.B
      ((Var 's' e.PIndex) ':' (Var e.HIndex))
      e.M
      ((Symbol s.Type e.Info) ':' (Var e.HIndex))
      e.E
    = <Solution-PostProcess
        <AddContraction
          ((Var 's' e.PIndex) ':' (Symbol s.Type e.Info))
          (e.Contractions)
          (e.B ((Symbol s.Type e.Info) ':' (Var e.HIndex)) e.M e.E)
        >
      >;

  (e.Contractions) (e.Assigns)
    , e.Assigns
    : e.B
      ((Symbol s.Type e.Info) ':' (Var e.HIndex))
      e.M
      ((Var 's' e.PIndex) ':' (Var e.HIndex))
      e.E
    = <Solution-PostProcess
        <AddContraction
          ((Var 's' e.PIndex) ':' (Symbol s.Type e.Info))
          (e.Contractions)
          (e.B ((Symbol s.Type e.Info) ':' (Var e.HIndex)) e.M e.E)
        >
      >;

  /*
     Если есть непротиворечивые присваивания вида:
     (X <- v.A) (X <- v.A) то удаляем одно из них
  */

  (e.Contractions) (e.Assigns)
    , e.Assigns
    : e.B
      ((Symbol s.Type e.Info) ':' (Var e.HIndex))
      e.M
      ((Symbol s.Type e.Info) ':' (Var e.HIndex))
      e.E
    = <Solution-PostProcess
        (e.Contractions)
        (e.B ((Symbol s.Type e.Info) ':' (Var e.HIndex)) e.M e.E)
      >;

  /*
    Если есть противоречивые присваивания вида:
    (X <- s.A) и (Y <- s.A) то ничего не возвращаем
  */

  (e.Contractions) (e.Assigns)
    , e.Assigns
    : e.B
      ((Symbol e.Info1) ':' (Var e.HIndex))
      e.M
      ((Symbol e.Info2) ':' (Var e.HIndex))
      e.E
    = /* пусто, т.к. противоречие */;

  (e.Contractions) (e.Assigns)
    , e.Assigns
    : e.B
      (e.Expr1 ':' (Var e.HIndex))
      e.M
      (e.Expr2 ':' (Var e.HIndex))
      e.E
    = Undefined;

  /*
    Здесь намеренно не рассмотрены случаи вида
    {{ &F\1 … }} ← var && s.X ← var,
    поскольку они приводят к бессмысленным сужениям вида
    s.X → {{ &F\1 … }}
  */


  (e.Contractions) (e.Assigns) = Success (e.Contractions) (e.Assigns)
}

/*
  <Solve-Aux (e.UsedVars) (t.Contr*) t.Equation* (t.Assign*)>
    == t.Result*

    t.Contr ::= (t.Var ':' e.Val)
    t.Equation ::= ((e.Expr) ':' (e.LExpr))
    t.Assign ::= (e.Val ':' t.Var)
    t.Result ::= Success ((t.Contr*) (t.Assign*)) | Undefined
*/

Solve-Aux {
  /* В начале системы уравнение вида T E : Lt Le  */
  (e.UsedVars) (e.Contrs) ((t.Pt e.Pe) ':' (t.Ht e.He)) e.Equations (e.Assigns)
    , <IsTerm t.Ht> : True
    , <IsTerm t.Pt> : True
    = <Solve-TermEquation
        (e.UsedVars)
        t.Pt t.Ht
        (e.Contrs) ((e.Pe) ':' (e.He)) e.Equations (e.Assigns)
      >
    : {
        Success e.PRTC = <Solve-Aux e.PRTC>;
        Failure =
      };

  /* В начале системы уравнение вида E T: Le Lt */
  (e.UsedVars) (e.Contrs) ((e.Pe t.Pt) ':' (e.He t.Ht)) e.Equations (e.Assigns)
    , <IsTerm t.Ht> : True
    , <IsTerm t.Pt> : True
    = <Solve-TermEquation
        (e.UsedVars)
        t.Pt t.Ht
        (e.Contrs) ((e.Pe) ':' (e.He)) e.Equations (e.Assigns)
      >
    : {
        Success e.PRTC = <Solve-Aux e.PRTC>;
        Failure =
      };

  /* Уравнения вида e.x E : Lt Le
     Разделяем на две независимые системы
     e.x -> empty
     e.x -> t.N e.N+1
  */
  (e.UsedVars) (e.Contrs) ((t.Pt e.Pe) ':' (t.Ht e.He))
  e.Equations (e.Assigns)
    , <IsTerm t.Ht> : True
    , t.Pt : (Var 'e' e.Index)
    = <NewVarName (e.UsedVars) 't'> : (e.UsedVars^) 't' e.tIdx
    = <NewVarName (e.UsedVars) 'e'> : (e.UsedVars^) 'e' e.eIdx
    = <AddContraction
        (t.Pt ':' )
        (e.Contrs)
        ((e.Pe) ':' (t.Ht e.He)) e.Equations
        (e.Assigns)
      >
    : e.Branch1
    = <AddContraction
        (t.Pt ':' (Var 't' e.tIdx) (Var 'e' e.eIdx))
        (e.Contrs)
        ((t.Pt e.Pe) ':' (t.Ht e.He)) e.Equations
        (e.Assigns)
      >
    : e.Branch2
    = <Solve-Aux (e.UsedVars) e.Branch1>
      <Solve-Aux (e.UsedVars) e.Branch2>;

  /* Уравнения вида E e.x : Le Lt
     Разделяем на две независимые системы
     e.x -> empty
     e.x -> e.N+1 t.N
  */
  (e.UsedVars) (e.Contrs) ((e.Pe t.Pt) ':' (e.He t.Ht))
  e.Equations (e.Assigns)
    , <IsTerm t.Ht> : True
    , t.Pt : (Var 'e' e.Index)
    = <NewVarName (e.UsedVars) 't'> : (e.UsedVars^) 't' e.tIdx
    = <NewVarName (e.UsedVars) 'e'> : (e.UsedVars^) 'e' e.eIdx
    = <AddContraction
        (t.Pt ':' )
        (e.Contrs)
        ((e.Pe) ':' (e.He t.Ht)) e.Equations
        (e.Assigns)
      >
    : e.Branch1
    = <AddContraction
        (t.Pt ':' (Var 'e' e.eIdx) (Var 't' e.tIdx))
        (e.Contrs)
        ((e.Pe t.Pt) ':' (e.He t.Ht)) e.Equations
        (e.Assigns)
      >
    : e.Branch2
    = <Solve-Aux (e.UsedVars) e.Branch1>
      <Solve-Aux (e.UsedVars) e.Branch2>;

  /* Если уравнение имеет вид Expr: e.x, добавляем присванивание
     вида Expr <- e.x */
  (e.UsedVars) (e.Contrs) ((e.Pe) ':' ((Var 'e' e.Idx)))
  e.Equations (e.Assigns)
    = <Solve-Aux
        (e.UsedVars)
        (e.Contrs)
        e.Equations
        (e.Assigns (e.Pe ':' (Var 'e' e.Idx)))
      >;

  /* Если уравнение имеет вид empty: Lt Le, ничего не возвращаем */
  (e.UsedVars) (e.Contrs) (() ':' (t.Ht e.He)) e.Equations (e.Assigns)
    , <IsTerm t.Ht> : True
    = /* противоречие */;

  /* Если уравнение имеет вид empty: Le Lt, ничего не возвращаем */
  (e.UsedVars) (e.Contrs) (() ':' (e.He t.Ht)) e.Equations (e.Assigns)
    , <IsTerm t.Ht> : True
    = /* противоречие */;

  /* Если уравнение имеет вид e.i* : empty, возвращаем результат,
     предварительно добавив пустые сужения
  */
  (e.UsedVars) (e.Contrs) ((e.Pt) ':' ()) e.Equations (e.Assigns)
    , <IsFreeVariableSeq e.Pt>
    : {
        True
          = <Map { t.Free = (t.Free ':' ) } e.Pt> : e.NewContrs
          = <Solve-Aux
              (e.UsedVars)
              <AddContractions
                (e.NewContrs)
                (e.Contrs)
                e.Equations
                (e.Assigns)
              >
            >;

        False = /* нет решений */;
      };

  (e.UsedVars) (e.Contrs) (e.Assigns)
    = <Solution-PostProcess (e.Contrs) (e.Assigns)>;

  e.Other = Undefined
}


/*
  Решает уравнение вида P:H для термов

  <Solve-TermEquation (e.UsedVars) t.Symbol1 t.Symbol2 e.PRTC>
    == t.Result

    t.Result ::= Success t.PRTC | Failure
    e.PRTC :: = (t.Contrs*) t.Equations* (t.Assigns*)

    PRTC - partially resolved term clash
*/

Solve-TermEquation {
  /* H является символом */
  (e.UsedVars) t.Symbol t.Symbol e.PRTC
    , t.Symbol : (Symbol s.Type e.Info)
    = Success (e.UsedVars) e.PRTC
  /* нет подстановок, нет сужений */;

  /* P - символ, H - s-переменная */
  (e.UsedVars) t.Symbol t.Svar (e.Contrs) e.Equations (e.Assigns)
    , <IsSVarSubset t.Symbol> : True
    , t.Svar : (Var 's' e.Hindex)
    = Success
      (e.UsedVars)
      (e.Contrs) e.Equations
      (e.Assigns (t.Symbol ':' t.Svar));

  /* P - s-переменная, H - s-переменная */
  (e.UsedVars) t.PSvar t.HSvar (e.Contrs) e.Equations (e.Assigns)
    , t.PSvar t.HSvar
    : (Var 's' e.Pindex) (Var 's' e.Hindex)
    = Success
      (e.UsedVars)
      (e.Contrs)
      e.Equations
      (e.Assigns (t.PSvar ':' t.HSvar));


  /* P - s-переменная, H - символ */
  (e.UsedVars) t.Svar t.Symbol (e.Contrs) e.Equations (e.Assigns)
    , t.Svar : (Var 's' e.Pindex)
    , <IsSVarSubset t.Symbol> : True
    = Success
      (e.UsedVars)
      <AddContraction
        (t.Svar ':' t.Symbol)
        (e.Contrs)
        e.Equations
        (e.Assigns)
      >;

  /* P - терм, H - t-переменная */
  (e.UsedVars) t.PVar t.HVar (e.Contrs) e.Equations (e.Assigns)
    , t.HVar: (Var 't' e.Tindex)
    = Success
      (e.UsedVars)
      (e.Contrs)
      e.Equations
      (e.Assigns (t.PVar':'(Var 't' e.Tindex)));

  /* P - t-переменная, H - скобочный терм */
  (e.UsedVars) t.PTvar (Brackets e.HBody) (e.Contrs) e.Equations (e.Assigns)
    , t.PTvar : (Var 't' e.Pindex)
    = <NewVarName (e.UsedVars) 'e'>
      : t.NewVars 'e' e.NewIndex
      = Success
        t.NewVars
        <AddContraction
          (t.PTvar ':' (Brackets (Var 'e' e.NewIndex)))
          (e.Contrs)
          e.Equations (((Var 'e' e.NewIndex)) ':' (e.HBody))
          (e.Assigns)
        >;

  /* P - t-переменная, H - скобочный терм */
  (e.UsedVars)
  t.PTvar (ADT-Brackets (e.Name) e.HBody)
  (e.Contrs) e.Equations (e.Assigns)
    , t.PTvar : (Var 't' e.Pindex)
    = <NewVarName (e.UsedVars) 'e'>
    : t.NewVars 'e' e.NewIndex
    = Success
      t.NewVars
      <AddContraction
        (t.PTvar ':' (ADT-Brackets (e.Name) (Var 'e' e.NewIndex)))
        (e.Contrs)
        e.Equations (((Var 'e' e.NewIndex)) ':' (e.HBody))
        (e.Assigns)
      >;

  /* P - t-переменная, H - символ */
  (e.UsedVars) t.PTvar t.Symbol (e.Contrs) e.Equations (e.Assigns)
    , t.PTvar t.Symbol
    : (Var 't' e.Pindex) (Symbol s.Type e.Info)
    = Success
      (e.UsedVars)
      <AddContraction
        (t.PTvar ':' t.Symbol)
        (e.Contrs)
        e.Equations
        (e.Assigns)
      >;

  /* P - t-переменная, H - s-переменная */
  (e.UsedVars) t.PTvar t.HSvar (e.Contrs) e.Equations (e.Assigns)
    , t.PTvar t.HSvar
    : (Var 't' e.Pindex) (Var 's' e.Hindex)
    = <NewVarName (e.UsedVars) 's' e.Hindex> : (e.UsedVars^) 's' e.sIdx
    = Success
      (e.UsedVars)
      <AddContraction
        (t.PTvar ':' (Var 's' e.sIdx))
        (e.Contrs)
        e.Equations
        (e.Assigns ((Var 's' e.sIdx) ':' t.HSvar))
      >;

  /* H является (H′) */
  (e.UsedVars)
  (Brackets e.TBody)(Brackets e.HBody)
  (e.Contrs) e.Equations (e.Assigns)
    = Success
      (e.UsedVars)
      (e.Contrs) e.Equations ((e.TBody) ':' (e.HBody))
      (e.Assigns);

  /* H является [H′] */
  (e.UsedVars)
  (ADT-Brackets (e.Name) e.TBody)(ADT-Brackets (e.Name) e.HBody)
  (e.Contrs) e.Equations (e.Assigns)
    = Success
      (e.UsedVars)
      (e.Contrs) e.Equations ((e.TBody) ':' (e.HBody)) (e.Assigns);

  e.Other = Failure
}

/*
  Добавляет в левую часть уравнения метки координат

  <AddCoordinateLabels e.Expr> == e.Expr^
  <AddCoordinateLabels-Helper (e.Expr) s.CoordsNumber> == e.Expr^
*/

AddCoordinateLabels {
  e.Expr = ('{'1'}') <AddCoordinateLabels-Helper (e.Expr) 2>
}

AddCoordinateLabels-Helper {
  ((Symbol s.SymType e.SymInfo) e.Rest) s.CoordNumber
    = (Symbol s.SymType e.SymInfo) ('{'s.CoordNumber'}')
      <AddCoordinateLabels-Helper (e.Rest) <Add s.CoordNumber 1>>;

  ((Var s.Mode e.Index) e.Rest) s.CoordNumber
    = (Var s.Mode e.Index) ('{'s.CoordNumber'}')
      <AddCoordinateLabels-Helper (e.Rest) <Add s.CoordNumber 1>>;

  ((ClosureBrackets e.Inner) e.Rest) s.CoordNumber
    = (ClosureBrackets e.Inner) ('{'s.CoordNumber'}')
      <AddCoordinateLabels-Helper (e.Rest) <Add s.CoordNumber 1>>;

  ((Brackets e.Expr) e.Rest) s.CoordNumber
    = (Brackets ('{'s.CoordNumber'}')
      <AddCoordinateLabels-Helper (e.Expr) <Add s.CoordNumber 1>>)
    : {
        (Brackets e.Inner ('{'s.LastCoord'}'))
          = (Brackets e.Inner ('{'s.LastCoord'}'))
            ('{'<Add s.LastCoord 1>'}')
            <AddCoordinateLabels-Helper (e.Rest) <Add s.LastCoord 2>>
      };

  ((ADT-Brackets (e.Name) e.Expression) e.Rest) s.CoordNumber
    = (ADT-Brackets (e.Name) ('{'s.CoordNumber'}')
      <AddCoordinateLabels-Helper (e.Expression) <Add s.CoordNumber 1>>)
    : {
        (ADT-Brackets e.Inner ('{'s.LastCoord'}'))
          = (ADT-Brackets e.Inner ('{'s.LastCoord'}'))
            ('{'<Add s.LastCoord 1>'}')
            <AddCoordinateLabels-Helper (e.Rest) <Add s.LastCoord 2>>
      };

  (e.Other) s.CoordNumber
    = e.Other;
}

/*
  Упрощение координат (редуцирование их бессмысленного скопления)

  <SimplifyCoordinates (t.Contr*) t.Clash* (t.Assign*)>
    == (t.Contr*) t.Clash^* (t.Assign^*)
*/

SimplifyCoordinates {
  (e.Contrs) e.Clashes (e.Assigns)
    = (e.Contrs)
      <Map &SimplifyCoordinates-Clash e.Clashes>
      (<Map &SimplifyCoordinates-Assign e.Assigns>)
}

SimplifyCoordinates-Clash {
  ((e.Left) ':' (e.Right))
    = ((<SimplifyCoordinates-Expr e.Left>) ':' (e.Right))
}

SimplifyCoordinates-Assign {
  (e.Left ':' t.Right)
    = (<SimplifyCoordinates-Expr e.Left> ':' t.Right)
}

SimplifyCoordinates-Expr {
  /* {k} {m} E {n}  ↦  {m} E {n} */
  ('{'s.K'}') ('{'s.M'}') e.E ('{'s.N'}')
    = <SimplifyCoordinates-Expr ('{'s.M'}') e.E ('{'s.N'}')>;

  /* {k} E {m} {n}  ↦  {k} E {m} */
  ('{'s.K'}') e.E ('{'s.M'}') ('{'s.N'}')
    = <SimplifyCoordinates-Expr ('{'s.K'}') e.E ('{'s.M'}')>;

  /* {m} {n}  ↦  ε */
  ('{'s.M'}') ('{'s.N'}')
    = /* пусто */;

  ('{'s.M'}') e.E ('{'s.N'}')
    = ('{'s.M'}') <SimplifyCoordinates-Expr-Inner e.E> ('{'s.N'}');

  /* пусто */ = /* пусто */;
}

SimplifyCoordinates-Expr-Inner {
  /* Ê1{k} {m} {n}Ê2  ↦  Ê1{k} {n}Ê2 */
  e.E1 ('{'s.K'}') ('{'s.M'}') ('{'s.N'}') e.E2
    = <SimplifyCoordinates-Expr-Inner e.E1 ('{'s.K'}') ('{'s.N'}') e.E2>;

  e.Begin (Brackets e.E) e.End
    = <SimplifyCoordinates-Expr-Inner e.Begin>
      (Brackets <SimplifyCoordinates-Expr e.E>)
      <SimplifyCoordinates-Expr-Inner e.End>;

  e.Begin (ADT-Brackets (e.Name) e.E) e.End
    = <SimplifyCoordinates-Expr-Inner e.Begin>
      (ADT-Brackets (e.Name) <SimplifyCoordinates-Expr e.E>)
      <SimplifyCoordinates-Expr-Inner e.End>;

  e.E = e.E;
}

/*
  <Solve-Aux-Spec (e.UsedVars) (t.Contr*) t.Clash* (t.Assign*)>
    == t.Result*

    t.Contr ::= (t.Var ':' e.Val)
    t.Clash ::= ((e.Expr) ':' (e.LExpr))
    t.Assign ::= (e.Val ':' t.Var)
*/

Solve-Aux-Spec {
  /* {m} T {n} : t.X   ↦  {m} T {n} ← t.X */
  (e.UsedVars) (e.Contrs) e.ClashesStart
  ((('{'s.M'}') t.T ('{'s.N'}')) ':' (t.X))
  e.ClashesEnd (e.Assigns)
    , <IsTerm t.T> : True
    , t.X : (Var 't' e.Tindex)
    = <Solve-Aux-Spec
        (e.UsedVars)
        (e.Contrs)
        e.ClashesStart e.ClashesEnd
        (e.Assigns (('{'s.M'}') t.T ('{'s.N'}') ':' t.X))
      >;

  /* {m} Sym {n} : s.X   ↦  {m} Sym {n} ← s.X */
  (e.UsedVars) (e.Contrs) e.ClashesStart
  ((('{'s.M'}') t.Sym ('{'s.N'}')) ':' (t.X))
  e.ClashesEnd (e.Assigns)
    , <IsSVarSubset t.Sym> : True
    , t.X : (Var 's' e.Sindex)
    = <Solve-Aux-Spec
        (e.UsedVars)
        (e.Contrs)
        e.ClashesStart e.ClashesEnd
        (e.Assigns (('{'s.M'}') t.Sym ('{'s.N'}') ':' t.X))
      >;

  /* {m} (E) {n} : (P)   ↦  {m} E {n} : P */
  (e.UsedVars) (e.Contrs) e.ClashesStart
  ((('{'s.M'}') t.L ('{'s.N'}')) ':' (t.R))
  e.ClashesEnd (e.Assigns)
    , t.L : (Brackets e.LBody)
    , t.R : (Brackets e.RBody)
    = <Solve-Aux-Spec
        (e.UsedVars)
        (e.Contrs) e.ClashesStart
        <SimplifyCoordinates-Clash
          ((('{'s.M'}') e.LBody ('{'s.N'}')) ':' (e.RBody))
        >
        e.ClashesEnd (e.Assigns)
      >;

  /* {m} [E] {n} : [P]   ↦  {m} E {n} : P */
  (e.UsedVars) (e.Contrs) e.ClashesStart
  ((('{'s.M'}') t.L ('{'s.N'}')) ':' (t.R))
  e.ClashesEnd (e.Assigns)
    , t.L : (ADT-Brackets (e.Name) e.LBody)
    , t.R : (ADT-Brackets (e.Name) e.RBody)
    = <Solve-Aux-Spec
        (e.UsedVars)
        (e.Contrs) e.ClashesStart
        <SimplifyCoordinates-Clash
          ((('{'s.M'}') e.LBody ('{'s.N'}')) ':' (e.RBody))
        >
        e.ClashesEnd (e.Assigns)
      >;

  /* {m} (E) {n} : Psym  ↦  нет решений */
  (e.UsedVars) (e.Contrs) e.ClashesStart
  ((('{'s.M'}') t.L ('{'s.N'}')) ':' (t.Psym))
  e.ClashesEnd (e.Assigns)
    , t.L : (Brackets e.LBody)
    , <IsSVarSubset t.Psym> : True
    = /* нет решений */;

  /* {m} [E] {n} : Psym  ↦  нет решений */
  (e.UsedVars) (e.Contrs) e.ClashesStart
  ((('{'s.M'}') t.L ('{'s.N'}')) ':' (t.Psym))
  e.ClashesEnd (e.Assigns)
    , t.L : (ADT-Brackets (e.LName) e.LBody)
    , <IsSVarSubset t.Psym> : True
    = /* нет решений */;

  /* {m} Sym {n} : (P)  ↦  нет решений */
  (e.UsedVars) (e.Contrs) e.ClashesStart
  ((('{'s.M'}') t.Sym ('{'s.N'}')) ':' (t.R))
  e.ClashesEnd (e.Assigns)
    , <IsSVarSubset t.Sym> : True
    , t.R : (Brackets e.RBody)
    = /* нет решений */;

  /* {m} Sym {n} : [P]  ↦  нет решений */
  (e.UsedVars) (e.Contrs) e.ClashesStart
  ((('{'s.M'}') t.Sym ('{'s.N'}')) ':' (t.R))
  e.ClashesEnd (e.Assigns)
    , <IsSVarSubset t.Sym> : True
    , t.R : (ADT-Brackets (e.RName) e.RBody)
    = /* нет решений */;

  /* {m} t.X {n} : (P)  ↦  t.X → (e.NEW) */
  (e.UsedVars) (e.Contrs) e.ClashesStart
  ((('{'s.M'}') t.X ('{'s.N'}')) ':' (t.P))
  e.ClashesEnd (e.Assigns)
    , t.X : (Var 't' e.Tindex)
    , t.P : (Brackets e.PBody)
    = <NewVarName (e.UsedVars) 'e' e.Tindex> : t.NewVars 'e' e.NewIndex
    = <Solve-Aux-Spec
        t.NewVars
        <AddContraction-Spec
          (t.X ':' (Brackets (Var 'e' e.NewIndex)))
          (e.Contrs) e.ClashesStart
          ((('{'s.M'}') t.X ('{'s.N'}')) ':' (t.P))
          e.ClashesEnd (e.Assigns)
        >
      >;

  /* {m} t.X {n} : [P]   ↦  t.X → [e.NEW] */
  (e.UsedVars) (e.Contrs) e.ClashesStart
  ((('{'s.M'}') t.X ('{'s.N'}')) ':' (t.P))
  e.ClashesEnd (e.Assigns)
    , t.X : (Var 't' e.Tindex)
    , t.P : (ADT-Brackets (e.PName) e.PBody)
    = <NewVarName (e.UsedVars) 'e' e.Tindex> : t.NewVars 'e' e.NewIndex
    = <Solve-Aux-Spec
        t.NewVars
        <AddContraction-Spec
          (t.X ':' (ADT-Brackets (e.PName) (Var 'e' e.NewIndex)))
          (e.Contrs) e.ClashesStart
          ((('{'s.M'}') t.X ('{'s.N'}')) ':' (t.P))
          e.ClashesEnd (e.Assigns)
        >
      >;

  /* {m} t.X {n} : Psym  ↦  t.X → s.NEW */
  (e.UsedVars) (e.Contrs) e.ClashesStart
  ((('{'s.M'}') t.X ('{'s.N'}')) ':' (t.Psym))
  e.ClashesEnd (e.Assigns)
    , t.X : (Var 't' e.Tindex)
    , <IsSVarSubset t.Psym> : True
    = <NewVarName (e.UsedVars) 's' e.Tindex> : t.NewVars 's' e.NewIndex
    = <Solve-Aux-Spec
        t.NewVars
        <AddContraction-Spec
          (t.X ':' (Var 's' e.NewIndex))
          (e.Contrs) e.ClashesStart
          ((('{'s.M'}') t.X ('{'s.N'}')) ':' (t.Psym))
          e.ClashesEnd (e.Assigns)
        >
      >;

  /* {m} s.X {n} :  X  ↦  s.X → X */
  (e.UsedVars) (e.Contrs) e.ClashesStart
  ((('{'s.M'}') t.X ('{'s.N'}')) ':' (t.S))
  e.ClashesEnd (e.Assigns)
    , t.X : (Var 's' e.Sindex)
    , t.S : (Symbol e._)
    = <Solve-Aux-Spec
        (e.UsedVars)
        <AddContraction-Spec
          (t.X ':' t.S)
          (e.Contrs) e.ClashesStart
          ((('{'s.M'}') t.X ('{'s.N'}')) ':' (t.S))
          e.ClashesEnd (e.Assigns)
        >
      >;

  /*  {m} X {n}  :  X    ↦  стираем */
  (e.UsedVars) (e.Contrs) e.ClashesStart
  ((('{'s.M'}') t.X ('{'s.N'}')) ':' (t.X))
  e.ClashesEnd (e.Assigns)
    , t.X : (Symbol e._)
    = <Solve-Aux-Spec
        (e.UsedVars)
        (e.Contrs)
        e.ClashesStart e.ClashesEnd
        (e.Assigns)
      >;

  /*  {m} X {n}  :  Y    ↦  нет решений */
  (e.UsedVars) (e.Contrs) e.ClashesStart
  ((('{'s.M'}') t.X ('{'s.N'}')) ':' (t.Y))
  e.ClashesEnd (e.Assigns)
    , t.X : (Symbol e._)
    , t.Y : (Symbol e._)
    = /* нет решений */;

  /* {m} T {n} E : Pt P   ↦  {m} T {n} : Pt  &&  {n} E : P */
  (e.UsedVars) (e.Contrs) e.ClashesStart
  ((('{'s.M'}') t.T ('{'s.N'}') e.E) ':' (t.Pt e.P))
  e.ClashesEnd (e.Assigns)
    , <IsTerm t.T> : True
    , <IsTerm t.Pt> : True
    = <Solve-Aux-Spec
        (e.UsedVars) (e.Contrs) e.ClashesStart
        ((('{'s.M'}') t.T ('{'s.N'}')) ':' (t.Pt))
        ((('{'s.N'}') e.E) ':' (e.P))
        e.ClashesEnd (e.Assigns)
      >;

  /* E {m} T {n} : P  Pt  ↦  E {m} : P   &&  {m} T {n} : Pt */
  (e.UsedVars) (e.Contrs) e.ClashesStart
  ((e.E ('{'s.M'}') t.T ('{'s.N'}')) ':' (e.P t.Pt))
  e.ClashesEnd (e.Assigns)
    , <IsTerm t.T> : True
    , <IsTerm t.Pt> : True
    = <Solve-Aux-Spec
        (e.UsedVars) (e.Contrs) e.ClashesStart
        ((e.E ('{'s.M'}')) ':' (e.P))
        ((('{'s.M'}') t.T ('{'s.N'}')) ':' (t.Pt))
        e.ClashesEnd (e.Assigns)
      >;

  /* {m} T E* {n} E : Pt P   ↦  {m} T {n} : Pt  &&  {m} E* {n} E : P */
  (e.UsedVars) (e.Contrs) e.ClashesStart
  ((('{'s.M'}') t.T e.EInner ('{'s.N'}') e.EOuter) ':' (t.Pt e.P))
  e.ClashesEnd (e.Assigns)
    , <IsTerm t.T> : True
    , <HasTopLevelCoordinateLabels e.EInner> : False
    , <IsTerm t.Pt> : True
    = <Solve-Aux-Spec
        (e.UsedVars) (e.Contrs) e.ClashesStart
        ((('{'s.M'}') t.T ('{'s.N'}')) ':' (t.Pt))
        ((('{'s.M'}') e.EInner ('{'s.N'}') e.EOuter) ':' (e.P))
        e.ClashesEnd (e.Assigns)
      >;

  /* E {m} E* T {n} : P  Pt  ↦  E {m} E* {n} : P   &&  {m} T {n} : Pt */
  (e.UsedVars) (e.Contrs) e.ClashesStart
  ((e.EOuter ('{'s.M'}') e.EInner t.T ('{'s.N'}')) ':' (e.P t.Pt))
  e.ClashesEnd (e.Assigns)
    , <IsTerm t.T> : True
    , <HasTopLevelCoordinateLabels e.EInner> : False
    , <IsTerm t.Pt> : True
    = <Solve-Aux-Spec
        (e.UsedVars) (e.Contrs) e.ClashesStart
        ((e.EOuter ('{'s.M'}') e.EInner ('{'s.N'}')) ':' (e.P))
        ((('{'s.M'}') t.T ('{'s.N'}')) ':' (t.Pt))
        e.ClashesEnd (e.Assigns)
      >;

  /* {m} e.X E {n} : Pt P   ↦  e.X → t.NEW1 e.NEW2  ||  e.X → ε */
  (e.UsedVars) (e.Contrs) e.ClashesStart
  ((('{'s.M'}') t.X e.E ('{'s.N'}')) ':' (t.Pt e.P))
  e.ClashesEnd (e.Assigns)
    , t.X : (Var 'e' e.XIndex)
    , <IsTerm t.Pt> : True
    = <NewVarName (e.UsedVars) 't' e.XIndex> : t.NewVars1 't' e.New1
    = <NewVarName t.NewVars1 'e' e.XIndex> : t.NewVars2 'e' e.New2
    = <AddContraction-Spec
        (t.X ':' (Var 't' e.New1) (Var 'e' e.New2))
        (e.Contrs) e.ClashesStart
        ((('{'s.M'}') t.X e.E ('{'s.N'}')) ':' (t.Pt e.P))
        e.ClashesEnd (e.Assigns)
      >
    : e.Branch1
    = <AddContraction-Spec
        (t.X ':' /* пусто */)
        (e.Contrs) e.ClashesStart
        ((('{'s.M'}') t.X e.E ('{'s.N'}')) ':' (t.Pt e.P))
        e.ClashesEnd (e.Assigns)
      >
    : e.Branch2
    = <Solve-Aux-Spec t.NewVars2 e.Branch1>
      <Solve-Aux-Spec (e.UsedVars) e.Branch2>;

  /* {m} E e.X {n} : P  Pt  ↦  e.X → e.NEW1 t.NEW2  ||  e.X → ε */
  (e.UsedVars) (e.Contrs) e.ClashesStart
  ((('{'s.M'}') e.E t.X ('{'s.N'}')) ':' (e.P t.Pt))
  e.ClashesEnd (e.Assigns)
    , t.X : (Var 'e' e.XIndex)
    , <IsTerm t.Pt> : True
    = <NewVarName (e.UsedVars) 'e' e.XIndex> : t.NewVars1 'e' e.New1
    = <NewVarName t.NewVars1 't' e.XIndex> : t.NewVars2 't' e.New2
    = <AddContraction-Spec
        (t.X ':' (Var 'e' e.New1) (Var 't' e.New2))
        (e.Contrs) e.ClashesStart
        ((('{'s.M'}') e.E t.X ('{'s.N'}')) ':' (e.P t.Pt))
        e.ClashesEnd (e.Assigns)
      >
    : e.Branch1
    = <AddContraction-Spec
        (t.X ':' /* пусто */)
        (e.Contrs) e.ClashesStart
        ((('{'s.M'}') e.E t.X ('{'s.N'}')) ':' (e.P t.Pt))
        e.ClashesEnd (e.Assigns)
      >
    : e.Branch2
    = <Solve-Aux-Spec t.NewVars2 e.Branch1>
      <Solve-Aux-Spec (e.UsedVars) e.Branch2>;

  /* {m} E {n} : e.X  ↦  {m} E {n} ← e.X */
  (e.UsedVars) (e.Contrs) e.ClashesStart
  ((('{'s.M'}') e.E ('{'s.N'}')) ':' (t.X))
  e.ClashesEnd (e.Assigns)
    , t.X : (Var 'e' e.XIndex)
    = <Solve-Aux-Spec
        (e.UsedVars) (e.Contrs)
        e.ClashesStart e.ClashesEnd
        (e.Assigns (('{'s.M'}') e.E ('{'s.N'}') ':' t.X))
      >;

  /* {m} e.X E {n} : ε  ↦  e.X → ε */
  (e.UsedVars) (e.Contrs) e.ClashesStart
  ((('{'s.M'}') t.X e.E ('{'s.N'}')) ':' (/* пусто */))
  e.ClashesEnd (e.Assigns)
    , t.X : (Var 'e' e.XIndex)
    = <Solve-Aux-Spec
        (e.UsedVars)
        <AddContraction-Spec
          (t.X ':' /* пусто */)
          (e.Contrs) e.ClashesStart
          ((('{'s.M'}') t.X e.E ('{'s.N'}')) ':' (/* пусто */))
          e.ClashesEnd (e.Assigns)
        >
      >;

  /* {m}  T E  {n} : ε  ↦  решений нет */
  (e.UsedVars) (e.Contrs) e.ClashesStart
  ((('{'s.M'}') t.T e.E ('{'s.N'}')) ':' (/* пусто */))
  e.ClashesEnd (e.Assigns)
    , <IsTerm t.T> : True
    = /* решений нет */;

  /* Продолжение следует...

  (e.UsedVars) (e.Contrs) (e.Assigns)
    = <Solution-PostProcess (e.Contrs) (e.Assigns)>;

  e.Other = Undefined
  */
}

IsTerm {
  (Var 'e' e.Index) = False;

  /* Рассматриваем для оптимизаций встраивания, прогонки и специализации */
  (CallBrackets e.Nested) = False;
  (ColdCallBrackets e.Nested) = False;

  /* s-, t-переменная, скобки обоих видов, символ */
  t.OtherTerm = True;
}

/*
  Добавление нескольких сужений к PRTC

  <AddContractions (t.toAdd*) (t.Contraction*) t.Equation* (t.Assign*)>
    == PRTC
*/

AddContractions {
   (t.toAdd e.Rem) (e.Contractions) e.Equations (e.Assigns) =
     <AddContractions
        (e.Rem)
        <AddContraction
          t.toAdd
          (e.Contractions)
          e.Equations
          (e.Assigns)
        >
     >;

   () e.PRTC = e.PRTC;
}

/*
  Добавление сужения к PRTC

  <AddContraction t.toAdd (t.Contraction*) t.Equation* (t.Assign*)>
   == PRTC
*/
AddContraction {
  t.toAdd (e.Contractions) e.Equations (e.Assigns) =
    (e.Contractions t.toAdd)
    <ApplyContraction t.toAdd e.Equations (e.Assigns)>
}

AddContraction-Spec {
  t.toAdd (e.Contractions) e.Clashes (e.Assigns)
    = <SimplifyCoordinates
        (<Map (&ApplyContraction-toContraction t.toAdd) e.Contractions> t.toAdd)
        <Map (&ApplyContraction-toEquation t.toAdd) e.Clashes>
        (<Map (&ApplyContraction-toAssign t.toAdd) e.Assigns>)
      >
}

/*
  Применение сужения к PRTC

  <ApplyContraction t.Contraction t.Equation* (t.Assign*)>
    == t.Equation* (t.Assign*)
*/

ApplyContraction {
  t.Contraction e.Equations (e.Assigns) =
    <Map (&ApplyContraction-toEquation t.Contraction) e.Equations>
    (<Map (&ApplyContraction-toAssign t.Contraction) e.Assigns>)
}

/*
  Применение сужения к другому сужению

  <ApplyContraction-toContraction t.Contr t.OtherContr> == t.OtherContr^
*/

ApplyContraction-toContraction {
  t.Contr (t.Var ':' e.Right)
    = (t.Var ':' <ApplyContraction-toExpr t.Contr e.Right>);
}

/*
  Применение сужения к присваиванию

  <ApplyContraction-toAssign t.Contraction t.Assign == t.Assign
*/

ApplyContraction-toAssign {
   t.Contraction (e.M ':' t.Rval)
     = (<ApplyContraction-toExpr t.Contraction e.M> ':' t.Rval);
}

/*
   Применение сужения к уравнению

   <ApplyContraction-toEquation t.Contraction t.Equation> == t.Equation
*/

ApplyContraction-toEquation {
   t.Contraction ((e.Expr) ':' (e.Lexpr)) =
     ((<ApplyContraction-toExpr t.Contraction e.Expr>) ':' (e.Lexpr))
}

/*
    Применение сужения к выражению

    <ApplyContraction-toExpr t.Contraction e.Expr> == e.Expr
*/

ApplyContraction-toExpr {
   (t.Var ':' e.Lval) e.B t.Var e.E =
     <ApplyContraction-toExpr (t.Var ':' e.Lval) e.B>
     e.Lval
     <ApplyContraction-toExpr (t.Var ':' e.Lval) e.E>;

   t.Contraction e.B (Brackets e.M) e.E =
     <ApplyContraction-toExpr t.Contraction e.B>
     (Brackets <ApplyContraction-toExpr t.Contraction e.M>)
     <ApplyContraction-toExpr t.Contraction e.E>;

   t.Contraction e.B (ADT-Brackets e.M) e.E =
     <ApplyContraction-toExpr t.Contraction e.B>
     (ADT-Brackets <ApplyContraction-toExpr t.Contraction e.M>)
     <ApplyContraction-toExpr t.Contraction e.E>;

   t.Contraction e.Expr = e.Expr
}

/* Проверка на последовательность свободных переменных */

IsFreeVariableSeq {
   /* пусто */ = True;

   (Var 'e' e.Idx) e.Rem = <IsFreeVariableSeq e.Rem>;

   t.Other e.Rem = False
}

/*
  Проверка на то, что выражение содержит
  метки координат на верхнем уровне
*/

HasTopLevelCoordinateLabels {
  e.Begin ('{'s.M'}') e.End = True;

  e.Other = False
}
