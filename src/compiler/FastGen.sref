
//FROM LibraryEx
$EXTERN UnBracket, Map, Fetch, Inc;

//FROM Library
$EXTERN WriteLine;

ModifyE-Aux {
  (e.gen '$') e.tail = ;
  (#T '$' ((e.Rep)) e.otherRep ) e.tail (e.scanned) (e.else) =
    <ModifyE-Aux e.tail (e.scanned <ModifyBrackets e.Rep>) (e.else ( #T '$' e.otherRep))>;
  (e.gen '$' ((e.Rep)) e.otherRep ) e.tail (e.scanned) (e.else) =
    <ModifyE-Aux e.tail (e.scanned e.Rep) (e.else ( e.gen '$' e.otherRep))>;
  (#Brackets (e.Rep) e.otherRep ) e.tail (e.scanned) (e.else) =
    <ModifyE-Aux e.tail (e.scanned (#Brackets e.Rep)) (e.else (#Brackets e.otherRep))>;
  (e.gen) e.tail (e.scanned) (e.else) = <ModifyE-Aux e.tail (e.scanned (e.gen)) (e.else (e.gen))>;
  (e.scanned) (e.else) = (e.scanned) <ModifyE e.else>;
}

$ENTRY ModifyE {
  e.all =
    <ModifyE-Aux e.all (/*scanned*/) (/*else*/)>;
}

$ENTRY ModifyBrackets {
  e.all =
    <Map
      {
        (#Brackets e.inBrackets) = 
          (#Brackets <ModifyE <ModifyBrackets e.inBrackets>>);
        (e.any) = (e.any);
      }
      e.all
    >;
}


PreparePatternsFastGen-Aux {
  e.Pattern = 
    <Map
      {
        (s.type (e.idx) (( e.Replacement)) ) = (s.type '$' ((e.Replacement)) );
        (#Brackets e.inBrackets) = (#Brackets <PreparePatternsFastGen-Aux e.inBrackets>);
        (#ADT-Brackets (e.Name) e.inBrackets) = (#ADT-Brackets (e.Name) <PreparePatternsFastGen-Aux e.inBrackets>);
        (e.any) = (e.any);
      }
      e.Pattern
    >;
}

PreparePatternsFastGen {
  e.all =
    <Map
      { (e.sent) = (<PreparePatternsFastGen-Aux e.sent>); }
      e.all
    >;
}

SplitReps-Aux {
  (/* Scanned */) (/* Else */) = ;
  (s.Mode '$') e.Tail = ;
  (s.Mode '$' ()) e.Tail = ;
  (#Brackets (e.Rep) e.Replacements) e.Tail (e.Scanned) (e.Else) =
    <SplitReps-Aux e.Tail (e.Scanned (#Brackets e.Rep)) (e.Else (#Brackets e.Replacements))>;
  (s.Mode '$' ((e.Rep)) e.otherRep ) e.Tail (e.Scanned) (e.Else) =
    <SplitReps-Aux
      e.Tail 
      (e.Scanned (s.Mode '$' ((e.Rep))))
      (e.Else (s.Mode '$' e.otherRep))
    >;
  (s.Mode s.Type s.Value) e.Tail (e.Scanned) (e.Else) =
    <SplitReps-Aux
      e.Tail
      (e.Scanned (s.Mode s.Type s.Value))
      (e.Else (s.Mode s.Type s.Value))
    >;
  (e.Scanned) (e.Else) =
    ((e.Scanned)) <SplitReps-Aux e.Else ()()>;
}

SplitReps-Brackets {
  e.Reps =
    <Map
      {
        (#Brackets e.inBrackets) =
          (#Brackets <UnBracket <UnBracket <SplitReps e.inBrackets>>>);
        (e.Else) = (e.Else);
      }
      e.Reps
    >;
}

SplitReps-Stop {
  (e.Scanned) (s.Mode '$' ((e.Rep))) e.Tail =
    0 e.Scanned (s.Mode '$' ((e.Rep))) e.Tail;
  (e.Scanned) (e.Any) e.Tail =
    <SplitReps-Stop (e.Scanned (e.Any)) e.Tail>;
  (e.Scanned) = 1 e.Scanned;
}

SplitReps {
  e.Reps =
    <Fetch
      <SplitReps-Stop () <SplitReps-Brackets e.Reps>>
      {
        0 e.Any = ((e.Any));
        1 e.Any =
          <SplitReps-Aux e.Any (/* Scanned */) (/* Else */)>;
      }
    >;
}

$ENTRY FastGen-Terms {
  /* с #E переменной - все #E переменная */
  ((#E '$' e.Pattern1 )) ((#E '$' e.Pattern2 )) =
    (#E '$' e.Pattern1 e.Pattern2 );
  
  /* скобки с атомами */
  ((#ADT-Brackets (e.Name) e.1)) ((#Atom e.val)) =
    (#T '$' ((#ADT-Brackets (e.Name) e.1 )) (( #Atom e.val )) );
    
  ((#E '$' e.Pattern )) ((e.any)) =
    (#E '$' e.Pattern (((e.any))));
    
  ((e.any)) ((#E '$' e.Pattern)) =
    (#E '$' (((e.any))) e.Pattern );
  
  ((#Atom e.val)) ((#ADT-Brackets (e.Name) e.1)) =
    (#T '$' ((#Atom e.val)) ((#ADT-Brackets (e.Name) e.1 )) );
 
  ((#Brackets e.1)) ((#Atom e.val)) =
    (#T '$' (( #Brackets e.1 )) (( #Atom e.val )) );
  
  ((#Atom e.val)) ((#Brackets e.1)) =
    (#T '$' ((#Atom e.val)) ((#Brackets e.1 )) );
  
  /* скобки с #S переменной */
  ((#S '$' e.Pattern)) ((#Brackets e.body)) =
    (#T '$' ((#S '$' e.Pattern)) ((#Brackets e.body)) );
  
  ((#Brackets e.body)) ((#S '$' e.Pattern)) =
    (#T '$' ((#Brackets e.body)) ((#S '$' e.Pattern)) );
  
  /* и там и там скобки, разбираем содержимое */
  ((#Brackets e.1)) ((#Brackets e.2)) =
    (#Brackets <UnBracket <FastGen (e.1 ) (e.2 )>>);
  
  ((#ADT-Brackets (e.Name) e.1 )) ((#ADT-Brackets (e.Name) e.2 )) =
    (#ADT-Brackets (e.Name) <UnBracket <FastGen (e.1 ) (e.2 )>>);
  
  ((#ADT-Brackets (e.Name1) e.1 )) ((#ADT-Brackets (e.Name2) e.2 )) =
    (#T '$' (((#ADT-Brackets (e.Name1) e.1 ))) (((#ADT-Brackets (e.Name2) e.2 ))) );
    
  /* скобки с #T переменной */
  ((#T '$' e.Pattern)) ((#Brackets e.inBr)) =
    (#T '$' e.Pattern (((#Brackets e.inBr))) );
    
  ((#Brackets e.inBr)) ((#T '$' e.Pattern)) =
    (#T '$' (((#Brackets e.inBr))) e.Pattern );
  
  ((#T '$' e.Pattern)) ((#ADT-Brackets (e.Name) e.inBr)) =
    (#T '$' e.Pattern (((#ADT-Brackets (e.Name) e.inBr))) );
    
  ((#ADT-Brackets (e.Name) e.inBr)) ((#T '$' e.Pattern)) =
    (#T '$' (((#ADT-Brackets (e.Name) e.inBr))) e.Pattern );
  
  /* Атом */
  ((#Atom e.val)) ((#Atom e.val)) = (#Atom e.val);
  
  ((#Atom e.val1)) ((#Atom e.val2)) = 
    (#S '$' (( (#Atom e.val1) )) (( (#Atom e.val2) )) );
  
  ((#Atom e.val)) ((#S '$' e.Pattern)) =
    (#S '$' (( (#Atom e.val) )) e.Pattern );
  
  ((#S '$' e.Pattern)) ((#Atom e.val)) =
    (#S '$' e.Pattern (( (#Atom e.val) )) );
  
  ((#Atom e.val)) ((#T '$' e.Pattern)) =
    (#T '$' (( (#Atom e.val) )) e.Pattern );
  
  ((#T '$' e.Pattern)) ((#Atom e.val)) =
    (#T '$' e.Pattern (( (#Atom e.val) )) );

  /* #T переменная */
  ((#T '$' e.Pattern1)) ((#T '$' e.Pattern2)) =
    (#T '$' e.Pattern1 e.Pattern2);
    
  ((#T '$' e.Pattern1)) ((#S '$' e.Pattern2)) =
    (#T '$' e.Pattern1 e.Pattern2);
    
  ((#S '$' e.Pattern1)) ((#T '$' e.Pattern2)) =
    (#T '$' e.Pattern1 e.Pattern2);
  
  /* #S переменная */
  
  ((#S '$' e.Pattern1)) ((#S '$' e.Pattern2)) =
    (#S '$' e.Pattern1 e.Pattern2 );
}

FastGen-MeN {
  (t.left1 e.1 (#E e.inE1) e.2 )(t.left2 e.3 (#E e.inE2) e.4 ) =
    <FastGen-Terms (t.left1) (t.left2) >
    <FastGen-MeN 
        (e.1 (#E e.inE1) e.2 )(e.3 (#E e.inE2) e.4 )
    >;

  (e.1 (#E e.inE1) e.2 t.right1)(e.3 (#E e.inE2) e.4 t.right2) =
    <FastGen-MeN 
        (e.1 (#E e.inE1) e.2 )(e.3 (#E e.inE2) e.4 )
    >
    <FastGen-Terms (t.right1) (t.right2)>;

  ((#E '$' ((e.inE1)) )) ((#E '$' ((e.inE2)) )) =
    (#E '$' ((e.inE1)) ((e.inE2)) );

  ((#E '$' ((e.inE1)) )) ((#E '$' e.inE2)) = 
    (#E '$' ((e.inE1)) ((e.inE2)) );
  
  ((#E '$' e.inE1)) ((#E '$' ((e.inE2)) )) = 
    (#E '$' ((e.inE1)) ((e.inE2)) );
  
  ((#E '$' e.inE1)) ((#E '$' e.inE2)) = 
    (#E '$' ((e.inE1)) ((e.inE2)) );
  
  (e.in1)(e.in2) = 
    (#E '$' <SplitReps e.in1> <SplitReps e.in2> );
}

LengthComp {
  (t.1 e.tail1) (t.2 e.tail2) = <LengthComp (e.tail1) (e.tail2)>;
  () () = 1;
  e.1 = 0;
}

FastGen-K {
  1 (t.1 e.tail1) (t.2 e.tail2) = 
    <FastGen-Terms (t.1 ) (t.2 )> 
    <FastGen-K 1 (e.tail1) (e.tail2)>;
  1 () () = ;
  0 (e.1) (e.2) = (#E '$' ((e.1)) ((e.2 )) );
}

FastGen {
  /* 0. Тело функции состоит из одного предложения или из пустых образцов */
  (e.1) = (e.1);
  () () = ();

  /* 1. Предложения являются термами; cтроим БО согласно таблице */
  (t.1) (t.2) e.Tail = <FastGen (<FastGen-Terms (t.1) (t.2)>) e.Tail>;
  
  /* 1.5. Пара Е-шек */
  ((#E '$' e.Pattern1 )) ((#E '$' e.Pattern2 )) e.Tail =
    <FastGen
      ((#E '$' e.Pattern1 e.Pattern2 ))
      e.Tail
    >;

  /* 2. Предложения класса (M,N) */
  ( e.1 (#E '$' (e.Pattern1)) e.2 )
  ( e.3 (#E '$' (e.Pattern2)) e.4 )
  e.Tail =
    <FastGen
      (<FastGen-MeN
        ( e.1 (#E '$' (e.Pattern1)) e.2 )
        ( e.3 (#E '$' (e.Pattern2)) e.4 )
      >)
      e.Tail
    >;

  /* 2.5. Что-то среднее между (M, N) и (K) */
  ((#E '$' e.Pattern )) (e.any) e.Tail =
    <FastGen
      ((#E '$' e.Pattern <SplitReps e.any> ))
      e.Tail
    >;

  (e.any) ((#E '$' e.Pattern)) e.Tail =
    <FastGen
      ((#E '$' <SplitReps e.any> e.Pattern ))
      e.Tail
    >;

  /* 3. Предложения класса (K) */
  ( e.1 ) ( e.2 ) e.Tail =
    <FastGen
      (<FastGen-K
        <LengthComp ( e.1 ) ( e.2 )>
        ( e.1 ) ( e.2 )
      >)
      e.Tail
    >;

  /* 4. Все остальное */ 
  // (e.1) (e.2) = ((#E '$' ((<ModifyE e.1> )) ((<ModifyE e.2> )) ));
  (e.1) (e.2) = ((#E '$' ((e.1)) ((e.2)) ));
}

$ENTRY CreateFastGen {
  // args   e.Patterns
  // return FastGen with replacements
  e.Patterns =
    <FastGen
      <PreparePatternsFastGen
        e.Patterns
      >
    >;
}


